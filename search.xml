<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java学习笔记1——如何理解被 protected 修饰的成员变量？</title>
    <url>/2020/08/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812110050.jpg" alt=""></p>
<p>被 <code>protected</code> 修饰的成员对于本包和其子类可见：</p>
<ol>
<li>基类的 <code>protected</code> 成员在包内可见</li>
<li>若继承了基类的子类与基类不在同一个包中，那么在子类中，子类实例可以访问其从基类继承而来的 <code>protected</code> 方法，不能访问基类中的 <code>protected</code> 方法。</li>
</ol>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.base;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProFather</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"protected father"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与基类处于同一个包的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.base;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProSon1</span> <span class="keyword">extends</span> <span class="title">ProFather</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与基类处于不同包的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.base2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProSon2</span> <span class="keyword">extends</span> <span class="title">ProFather</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在基类所在的包中，基类，子类1和子类2都可以访问函数 <code>f()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与基类处于同一个包的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.base;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类可以访问函数f</span></span><br><span class="line">        ProFather father = <span class="keyword">new</span> ProFather();</span><br><span class="line">        father.f();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 子类1可以访问函数f</span></span><br><span class="line">        ProSon1 son1 = <span class="keyword">new</span> ProSon1();</span><br><span class="line">        son1.f();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子类2可以访问函数f</span></span><br><span class="line">        ProSon2 son2 = <span class="keyword">new</span> ProSon2();</span><br><span class="line">        son2.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在不同的包下，基类，子类1和子类2都不能访问函数 <code>f()</code>，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与基类处于不同包的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.base2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base2Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProFather father = <span class="keyword">new</span> ProFather();</span><br><span class="line">        <span class="comment">// f 方法被保护，在不同的包不可见</span></span><br><span class="line">        father.f();  <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">        ProSon1 son1 = <span class="keyword">new</span> ProSon1();</span><br><span class="line">        <span class="comment">// f 方法被保护，在不同的包不可见</span></span><br><span class="line">        son1.f();    <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">        ProSon2 son2 = <span class="keyword">new</span> ProSon2();</span><br><span class="line">        <span class="comment">// f 方法被保护，在不同的包不可见</span></span><br><span class="line">        son2.f();    <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类2中：</p>
<ol>
<li>基类无法访问函数 <code>f()</code></li>
<li>子类2可以访问函数 <code>f()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与基类处于不同包的son2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.base2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProSon2</span> <span class="keyword">extends</span> <span class="title">ProFather</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.f();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProFather father = <span class="keyword">new</span> ProFather();</span><br><span class="line">        <span class="comment">// f 方法被保护，在不同的包不可见</span></span><br><span class="line">        father.f();  <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">        ProSon2 son2 = <span class="keyword">new</span> ProSon2();</span><br><span class="line">        <span class="comment">// f 方法被 son2 继承，在子类可见</span></span><br><span class="line">        son2.f();    <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子类2重写了父类的 f 方法，并用 <code>protected</code> 修饰，那么在子类2所在的包下可以访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与基类处于不同包的子类2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.base2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProSon2</span> <span class="keyword">extends</span> <span class="title">ProFather</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProSon2 son2 = <span class="keyword">new</span> ProSon2();</span><br><span class="line">        <span class="comment">// f 方法被 son2 重写，在子类可见</span></span><br><span class="line">        son2.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与基类处于不同包的测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.demo.base2;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base2Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// f 方法来自于ProSon2在同一个包内可见</span></span><br><span class="line">        son2.f();  <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html" target="_blank" rel="noopener">Java protected 关键字详解</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java源码系列4——HashMap扩容时究竟对链表和红黑树做了什么?</title>
    <url>/2020/06/04/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%974%E2%80%94%E2%80%94HashMap%E6%89%A9%E5%AE%B9%E6%97%B6%E7%A9%B6%E7%AB%9F%E5%AF%B9%E9%93%BE%E8%A1%A8%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812105955.jpg" alt=""></p>
<p>我们知道 HashMap 的底层是由数组，链表，红黑树组成的，在 HashMap 做扩容操作时，除了把数组容量扩大为原来的两倍外，还会对所有元素重新计算 hash 值，因为长度扩大以后，hash值也随之改变。</p>
<a id="more"></a>
<p>如果是简单的 Node 对象，只需要重新计算下标放进去就可以了，如果是链表和红黑树，那么操作就会比较复杂，下面我们就来看下，JDK1.8 下的 HashMap 在扩容时对链表和红黑树做了哪些优化？</p>
<h2 id="rehash-时，链表怎么处理？"><a href="#rehash-时，链表怎么处理？" class="headerlink" title="rehash 时，链表怎么处理？"></a>rehash 时，链表怎么处理？</h2><p>假设一个 HashMap 原本 bucket 大小为 16。下标 3 这个位置上的 19, 3, 35 由于索引冲突组成链表。</p>
<p><img data-src="http://cdn.chaohang.top/20200602180032.png" alt="http://cdn.chaohang.top/20200602180032.png"></p>
<p>当 HashMap 由 16 扩容到 32 时，19, 3, 35 重新 hash 之后拆成两条链表。</p>
<p><img data-src="http://cdn.chaohang.top/20200603091606.png" alt="http://cdn.chaohang.top/20200603091606.png"></p>
<p>查看 JDK1.8 HashMap 的源码，我们可以看到关于链表的优化操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把原有链表拆成两个链表</span></span><br><span class="line"><span class="comment">// 链表1存放在低位（原索引位置）</span></span><br><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 链表2存放在高位（原索引 + 旧数组长度）</span></span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">// 链表1</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 链表1存放于原索引位置</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表2存放原索引加上旧数组长度的偏移量</span></span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常我们是把所有元素都重新计算一下下标值，再决定放入哪个桶，JDK1.8 优化成直接把链表拆成高位和低位两条，通过位运算来决定放在原索引处或者原索引加原数组长度的偏移量处。我们通过位运算来分析下。</p>
<p>先回顾一下原 hash 的求余过程：</p>
<p><img data-src="http://cdn.chaohang.top/20200603094454.png" alt=""></p>
<p>再看一下 rehash 时，判断时做的位操作，也就是这句 <code>e.hash &amp; oldCap</code>：</p>
<p><img data-src="http://cdn.chaohang.top/20200603094617.png" alt=""></p>
<p>再看下扩容后的实际求余过程：</p>
<p><img data-src="http://cdn.chaohang.top/20200603095225.png" alt=""></p>
<p>这波操作是不是很666，为什么 2 的整数幂 - 1可以作 &amp; 操作可以代替求余计算，因为 2 的整数幂 - 1 的二进制比较特殊，就是一串 11111，与这串数字 1 作 &amp; 操作，结果就是保留下原数字的低位，去掉原数字的高位，达到求余的效果。2 的整数幂的二进制也比较特殊，就是一个 1 后面跟上一串 0。</p>
<p>HashMap 的扩容都是扩大为原来大小的两倍，从二进制上看就是给这串数字加个 0，比如 16 -&gt; 32 = 10000 -&gt; 100000，那么他的 n - 1 就是 15 -&gt; 32 = 1111 -&gt; 11111。也就是多了一位，所以扩容后的下标可以从原有的下标推算出来。差异就在于上图我标红的地方，如果标红处是 0，那么扩容后再求余结果不变，如果标红处是 1，那么扩容后再求余就为原索引 + 原偏移量。如何判断标红处是 0 还是 1，就是把 <code>e.hash &amp; oldCap</code>。</p>
<h2 id="rehash-时，红黑树怎么处理？"><a href="#rehash-时，红黑树怎么处理？" class="headerlink" title="rehash 时，红黑树怎么处理？"></a>rehash 时，红黑树怎么处理？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树转链表阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容操作</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    <span class="comment">// 和链表同样的套路，分成高位和低位</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * TreeNode 是间接继承于 Node，保留了 next，可以像链表一样遍历</span></span><br><span class="line"><span class="comment">      * 这里的操作和链表的一毛一样</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// bit 就是 oldCap</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 尾插</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树化低位链表</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">              * hiHead == null 时，表明扩容后，</span></span><br><span class="line"><span class="comment">              * 所有节点仍在原位置，树结构不变，无需重新树化</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 树化高位链表，逻辑与上面一致</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出，红黑树的拆分和链表的逻辑基本一致，不同的地方在于，重新映射后，会将红黑树拆分成两条链表，根据链表的长度，判断需不需要把链表重新进行树化。</p>
<h2 id="源码系列文章"><a href="#源码系列文章" class="headerlink" title="源码系列文章"></a>源码系列文章</h2><p><a href="https://chaohang.top/2020/02/11/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94ArrayList/" target="_blank" rel="noopener">Java源码系列1——ArrayList</a></p>
<p><a href="https://chaohang.top/2020/02/12/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94HashMap/" target="_blank" rel="noopener">Java源码系列2——HashMap</a></p>
<p><a href="https://chaohang.top/2020/02/16/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94LinkedHashMap/" target="_blank" rel="noopener">Java源码系列3——LinkedHashMap</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">HashMap 源码详细分析(JDK1.8)</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java源码系</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL是如何实现可重复读的?</title>
    <url>/2020/06/02/MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812112751.jpg" alt=""></p>
<blockquote>
<p>《MySQL实战45讲》笔记。</p>
</blockquote>
<h2 id="简单理解一下可重复读"><a href="#简单理解一下可重复读" class="headerlink" title="简单理解一下可重复读"></a>简单理解一下可重复读</h2><p>可重复读是指：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</p>
<a id="more"></a>
<p>我们可以简单理解为：在可重复读隔离级别下，事务在启动的时候就”拍了个快照“。注意，这个快照是基于整个库的。</p>
<p>这时，你可能就会想，如果一个库有 100G，那么我启动一个事务，MySQL就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。</p>
<p>实际上，我们并不需要拷贝出这 100G 的数据。我们来看下”快照“是怎么实现的。</p>
<h2 id="拍个快照"><a href="#拍个快照" class="headerlink" title="拍个快照"></a>拍个快照</h2><p>InnoDB 里面每个事务都有一个唯一的事务 ID，叫作 transaction id。它在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p>
<p>每条记录在更新的时候都会同时记录一条 undo log，这条 log 就会记录上当前事务的 transaction id，记为 row trx_id。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p>如下图所示，一行记录被多个事务更新之后，最新值为 k=22。假设事务A在 trx_id=15 这个事务<strong>提交后启动</strong>，事务A 要读取该行时，就通过 undo log，计算出该事务启动瞬间该行的值为 k=10。</p>
<p><img data-src="http://cdn.chaohang.top/20200602084022.png" alt=""></p>
<p>在可重复读隔离级别下，一个事务在启动时，InnoDB 会为事务构造一个数组，用来保存这个事务启动瞬间，当前正在”活跃“的所有事务ID。”活跃“指的是，启动了但还没提交。</p>
<p>数组里面事务 ID 为最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>这个视图数组把所有的 row trx_id 分成了几种不同的情况。</p>
<p><img data-src="http://cdn.chaohang.top/20200602085031.png" alt=""></p>
<ol>
<li>如果 trx_id 小于低水位，表示这个版本在事务启动前已经提交，可见；</li>
<li>如果 trx_id 大于高水位，表示这个版本在事务启动后生成，不可见；</li>
<li>如果 trx_id 大于低水位，小于高水位，分为两种情况：<ol>
<li>若 trx_id 在数组中，表示这个版本在事务启动时还未提交，不可见；</li>
<li>若 trx_id 不在数组中，表示这个版本在事务启动时已经提交，可见。</li>
</ol>
</li>
</ol>
<p><strong>InnoDB 就是利用 undo log 和 trx_id 的配合，实现了事务启动瞬间”秒级创建快照“的能力。</strong></p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>初始化语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`k`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(<span class="keyword">id</span>, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>下表为事务A, B, C 的执行流程</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
<th>事务C</th>
</tr>
</thead>
<tbody>
<tr>
<td>START TRANSACTION WITH CONSISTENT SNAPSHOT;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>START TRANSACTION WITH CONSISTENT SNAPSHOT;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>UPDATE t SET k=k+1 WHERE id=1;</td>
</tr>
<tr>
<td></td>
<td>UPDATE t SET k=k+1 WHERE id=1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>SELECT k FROM t WHERE id=1;</td>
<td></td>
</tr>
<tr>
<td>SELECT k FROM t WHERE id=1;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>COMMIT;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>我们假设事务A, B, C 的 trx_id 分别为 100, 101, 102。事务A开始前活跃的事务 ID 只有 99，并且 id=1 这一行数据的 trx_id=90。</p>
<p>根据假设，我们得出事务启动瞬间的视图数组：事务A：[99, 100]，事务B：[99, 100, 101]，事务C：[99, 100, 101, 102]。</p>
<p><img data-src="http://cdn.chaohang.top/20200602091315.png" alt=""></p>
<ol>
<li>事务C通过更新语句，把 k 更新为 2，此时trx_id=102；</li>
<li>事务B通过更新语句，把 k 更新为 3，此时trx_id=101；</li>
<li>事务B通过查询语句，查询到最新一条记录为3，trx_id=101，满足隔离条件，返回 k=3；</li>
<li>事务A通过查询语句：<ol>
<li>查询到最新一条记录为3，trx_id=101，比高水位大，不可见；</li>
<li>通过 undo log，找到上一个历史版本，trx_id=102，比高水位大，不可见；</li>
<li>继续找上一个历史版本，trx_id=90，比低水位小，可见。</li>
</ol>
</li>
</ol>
<h3 id="提出问题：为啥事务B更新的时候能看到事务C的修改？"><a href="#提出问题：为啥事务B更新的时候能看到事务C的修改？" class="headerlink" title="提出问题：为啥事务B更新的时候能看到事务C的修改？"></a>提出问题：为啥事务B更新的时候能看到事务C的修改？</h3><p>我们假设事务B在更新的看不到事务C的修改，是什么个情况？</p>
<ol>
<li>事务B查询到最新一条记录为2，trx_id=102，比高水位大，不可见；</li>
<li>通过 undo log，找到上一个版本，trx_id=90，比低水位小，可见；</li>
<li>返回记录 k=1，执行 k=k+1，把 k 更新为2，此时 trx_id=101。</li>
</ol>
<p>如果是这种情况，事务C可能就蒙了：“啥子情况，我的更新怎么就丢了”。事务B覆盖了事务C的更新。</p>
<p>所以，InnoDB在更新时运用一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读“ （current read）。</strong></p>
<p>因此，事务B在更新时要拿到最新的数据，在此基础上做更新。紧接着，事务B在读取的时候，查询到最新的记录为3， trx_id=101 为当前事务ID，可见。</p>
<p>我们再假设另一种情况：</p>
<p>事务B在更新之后，事务C紧接着更新，事务B回滚了，事务C成功提交。</p>
<table>
<thead>
<tr>
<th>事务B</th>
<th>事务C</th>
</tr>
</thead>
<tbody>
<tr>
<td>START TRANSACTION WITH CONSISTENT SNAPSHOT;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>START TRANSACTION WITH CONSISTENT SNAPSHOT;</td>
</tr>
<tr>
<td>UPDATE t SET k=k+1 WHERE id=1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>UPDATE t SET k=k+1 WHERE id=1;</td>
</tr>
<tr>
<td></td>
<td>SELECT k FROM t WHERE id=1;</td>
</tr>
<tr>
<td>ROLLBACK;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>COMMIT;</td>
</tr>
</tbody>
</table>
<p>如果按照当前读的定义，会发生以下事故，假设当前 K=1：</p>
<ol>
<li>事务B把 k 更新为 2；</li>
<li>事务C读取到当前最新值，k=2，更新为3；</li>
<li>事务B回滚；</li>
<li>事务C提交。</li>
</ol>
<p>这时候，事务C发现自己想要执行的是 +1 操作，结果变成了 ”+2“ 操作。</p>
<p>InnoDB 肯定不允许这种情况的发生，事务B在执行更新语句时，会给该行加上行锁，直到事务B结束，才会释放这个锁。</p>
<p><img data-src="http://cdn.chaohang.top/20200602095159.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>InnoDB 的行数据有多个版本，每个版本都有 row trx_id。</li>
<li>事务根据 undo log 和 trx_id 构建出满足当前隔离级别的一致性视图。</li>
<li>可重复读的核心是一致性读，而事务更新数据的时候，只能使用当前读，如果当前记录的行锁被其他事务占用，就需要进入锁等待。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://time.geekbang.org/column/article/68963" target="_blank" rel="noopener">03 | 事务隔离：为什么你改了我还看不见？-极客时间</a></p>
<p><a href="https://time.geekbang.org/column/article/70562" target="_blank" rel="noopener">08 | 事务到底是隔离的还是不隔离的？-极客时间</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者 <a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>公众号【超超不会飞】</p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的各种日志</title>
    <url>/2020/06/01/MySQL%E7%9A%84%E5%90%84%E7%A7%8D%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812112555.jpg" alt=""></p>
<blockquote>
<p>《MySQL实战45讲》笔记。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-redo-log——只是一块粉板"><a href="#1-redo-log——只是一块粉板" class="headerlink" title="1. redo log——只是一块粉板"></a>1. redo log——只是一块粉板</h2><p>孔乙己又来酒馆喝酒，兜里没钱手机也没电了，只能向掌柜的赊账。掌柜有一块粉板，当客人要赊账的时候就往上写一笔，等客人少的时候或者粉板写满了就记到账本里去。还好有这块粉板，不然每次客人要赊账，掌柜都要翻看账本，在密密麻麻的账本里找到赊账客人的名字绝对不是一件容易的事，有了粉板，掌柜只要往粉板上记一笔：“孔乙己 赊 两文”，空闲的时候再更新到账本里去，简单多了。</p>
<p>同样的，MySQL也有一块“粉板”—— redo log。更新的时候，先写到 redo log 和内存里，这次更新就算是结束了。等到合适的时机再写到磁盘里，大大减小了写磁盘的次数。</p>
<p>redo log 是固定大小、“循环写”的，就像粉板一样，顶多也就记个十几二十条，多了就记不下了，这时会把粉板上的帐都写到账本里，再擦掉粉板，从头开始记。假设 redo log 配置了4组文件，每个文件 1G ，一共可记录 4G 的操作，写满了就会擦掉一部分记录。</p>
<p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生了异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p>
<h2 id="2-binlog"><a href="#2-binlog" class="headerlink" title="2. binlog"></a>2. binlog</h2><p>binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
<p>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如”给 ID=2 这一行的 c 字段加1“。</p>
<p>binlog 是“追加写”的，一个文件写完了会切换到下一个，不会覆盖以前的日志。</p>
<p><strong>为什么有了 redo log 还需要 binlog?</strong></p>
<p>其实 redo log 才是那个新来的仔。MySQL 自带了 binlog 日志用于归档，没有 crash-safe 的能力。InnoDB 引擎以插件的形式引入 MySQL 时，为了能够实现 crash-safe 的能力，引入了 redo log 。</p>
<p>一般我们用 binlog 做主从复制，数据恢复等操作。</p>
<p><strong>binlog 是如何做数据恢复的？</strong></p>
<p>一般我们做数据库备份是一周一备，一天一备，也可能一月一备。</p>
<p>假设今天中午12点，我们发现部分数据被误删了。需要恢复到昨天晚上8点这个时间段。但是数据库是每天凌晨3点的时候备份，离我们最近的一份备份数据已经缺失，只能恢复到昨天凌晨3点。这个时候我们就可以拿出昨天凌晨3点到晚上8点这个时间段的 binlog，重放到数据缺失前的那个时刻。在把这份数据恢复到线上数据库去。</p>
<h2 id="3-更新操作的执行流程"><a href="#3-更新操作的执行流程" class="headerlink" title="3. 更新操作的执行流程"></a>3. 更新操作的执行流程</h2><p>了解了 redo log 和 binlog 这两个日志的概念，我们再来看看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取 ID=2 这一行。如果数据在内存就直接返回，如果不在内存就先从磁盘读入内存，再返回。</li>
<li>执行器拿到数据，给这行的 c 值加 1。</li>
<li>引擎将这行数据的改动更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于<strong>prepare 状态</strong>。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成 <strong>commit 状态</strong>，更新完成。</li>
</ol>
<p>下图出自《MySQL实战45讲》，浅色框表示是在 InnoDB 内部执行的，深色框表示实在执行器中执行的。</p>
<p><img data-src="http://cdn.chaohang.top/20200528171340.png" alt=""></p>
<h2 id="4-redo-log-和-binlog-的两阶段提交"><a href="#4-redo-log-和-binlog-的两阶段提交" class="headerlink" title="4. redo log 和 binlog 的两阶段提交"></a>4. redo log 和 binlog 的两阶段提交</h2><p><strong>为什么需要两阶段提交？</strong></p>
<p>我们先假设没有两阶段提交时，可能会有以下两种情况：</p>
<ol>
<li>redo log 提交成功了，这时候数据库挂掉导致 binlog 没有成功写入。数据库重启之后通过 redo log 把数据恢复回来，但是 binlog 没有成功写入，导致我们在做主从复制或者数据恢复的时候，数据不一致。</li>
<li>binlog 提交成功了，这时候数据库挂掉导致 redo log 没有成功写入。数据库重启之后，无法恢复崩溃之前提交的那个事务，这部分数据更改在主库缺失。但是 binlog 已经成功写入了，从库反而有了该事务的改动，导致数据不一致。</li>
</ol>
<p>综上我们知道，redo log 和 binlog 必须同时成功或同时失败，才能保证数据一致性。</p>
<p><strong>两阶段提交是如何保证 redo log 和 binlog 同时成功或同时失败的？</strong></p>
<p><img data-src="http://cdn.chaohang.top/20200528174315.png" alt="图片来自《MySQL实战45讲》"></p>
<p>假设已经有了两阶段提交，分析一下以下两种情况：</p>
<ol>
<li>假设在上图的时刻A，redo log 处于 prepare 之后，写 binlog 之前，数据库挂掉了。由于此时 binlog 还没有写，redo log 也还没有提交，所以崩溃恢复后，这个事务会回滚。这时候 binlog 还没写，所以也不会传到备库。</li>
<li>假设在上图的时刻B，写 binlog 之后，redo log 还没有 commit 前发生 crash。那么崩溃恢复时，MySQL 会做以下判断：<ol>
<li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li>
<li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<br>a. 如果是，则提交事务；<br>b. 否则，回滚事务。</li>
</ol>
</li>
</ol>
<p><strong>那么 MySQL 是怎么知道 binlog 是否完整的？</strong></p>
<p>一个事务的 binlog 是有完整的格式的：</p>
<ul>
<li>statement 格式的 binlog，最后会有 COMMIT;</li>
<li>row 格式的 binlog，最后会有一个 XID event。</li>
</ul>
<h2 id="5-change-buffer"><a href="#5-change-buffer" class="headerlink" title="5. change buffer"></a>5. change buffer</h2><p><strong>什么是 change buffer ?</strong></p>
<p>当需要更新一个数据时，如果数据页在内存里就直接更新了，如果数据页不在内存里，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要读磁盘了。在下次查询需要访问到这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。</p>
<p>如果能够将更新操作先记录在 change buffer， 减少读磁盘，更新操作变快。而且数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。</p>
<p>change buffer 是可以持久化的数据，change buffer 在内存中有拷贝，也会被写入到磁盘中。</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。以下情况会触发 merge:</p>
<ol>
<li>访问数据页</li>
<li>系统有后台线程定期 merge</li>
<li>数据库正常关闭也会触发 merge</li>
</ol>
<p><strong>为什么普通索引比唯一索引效率高？</strong></p>
<ol>
<li>查询时：<ol>
<li>普通索引查出数据页，数据页读入内存，判断是否有相等的数据，返回数据。</li>
<li>唯一索引查出数据页，数据页读入内存，直接返回数据。</li>
<li>虽然普通索引多了一步判断，但是数据是以页为单位读入内存的，判断大概率是内存操作，消耗很小，可以忽略。</li>
</ol>
</li>
<li>更新时：<ol>
<li>普通索引直接更新内存或者缓存到 change buffer 中，结束。</li>
<li>唯一索引更新时需要判断是否有数据冲突，所以无法利用 change buffer，当数据页不在内存时，必须读磁盘写入内存再做判断，效率低于普通索引。</li>
</ol>
</li>
</ol>
<p><strong>什么情况下不适合使用 change buffer?</strong></p>
<p>如果某个业务更新后马上做查询，即使我们把更新先记录在 change buffer，读取操作也会马上把数据读入内存，而且立即触发 merge 操作。这种情况下，随机访问磁盘的次数没有减少，反而增加了 change buffer 的维护代价。所以对于这种业务，change buffer 反而起到了反作用。</p>
<h2 id="6-change-buffer-和-redo-log"><a href="#6-change-buffer-和-redo-log" class="headerlink" title="6. change buffer 和 redo log"></a>6. change buffer 和 redo log</h2><h3 id="插入时"><a href="#插入时" class="headerlink" title="插入时"></a>插入时</h3><p><img data-src="http://cdn.chaohang.top/20200528200342.png" alt=""></p>
<ol>
<li>插入的数据页刚好在内存中，直接更新内存中的数据页（上图1）。</li>
<li>数据页不在内存中，在 change buffer 里记录下对该数据页的改动（上图2）。</li>
<li>将上述两个动作记入 redo log 中（上图3，4）。</li>
</ol>
<p>我们可以看到，执行这条语句的成本很低，写了两处内存（内存和change buffer），写了一处磁盘（redo log，两次操作合在一起写磁盘），而且还是顺序写（直接写日志文件）。</p>
<p>同时，图中两个虚线箭头，是后台操作（异步操作，空闲时间就刷的那种），不影响该语句的响应时间。</p>
<h3 id="查询时"><a href="#查询时" class="headerlink" title="查询时"></a>查询时</h3><p><img data-src="http://cdn.chaohang.top/20200528201114.png" alt=""></p>
<ol>
<li>数据在内存时，直接读取。</li>
<li>数据不在内存时，从磁盘读入内存，然后应用 change buffer 里的操作日志，在内存生成一个最新的数据。</li>
</ol>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>从上面两个案例我们可以看出：</p>
<ol>
<li>redo log 主要节省的是随机写磁盘的 IO 消耗（把更新时的随机写磁盘转成顺序写）。</li>
<li>change buffer 主要节省的是随机读磁盘的 IO 消耗（减少更新时读磁盘的次数）。</li>
</ol>
<h2 id="7-binlog-和-redo-log-的持久化"><a href="#7-binlog-和-redo-log-的持久化" class="headerlink" title="7. binlog 和 redo log 的持久化"></a>7. binlog 和 redo log 的持久化</h2><h3 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a>binlog 的写入机制</h3><p>binlog 的写入逻辑：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p><strong>一个事务的 binlog 是不能被拆开写的，因此不论这个事务多大，也要确保一次性写入。</strong></p>
<p>系统给 binlog cache 分配了一片内存，<strong>每个线程一个</strong>，参数 <code>binlog_cache_size</code> 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存的磁盘中。</p>
<p>事务提交时，执行器把 binlog cache 里的完整事务写到 binlog file 和 磁盘中，并清空 binlog cache。状态如下图所示：</p>
<p><img data-src="http://cdn.chaohang.top/20200529170736.png" alt=""></p>
<ol>
<li>图中的 write，指的是日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，速度比较快。</li>
<li>图中的 fsync，指的是日志最终持久化到磁盘，速度慢。</li>
<li>write 和 fsync 的时机，由参数 sync_binlog 控制：<ol>
<li>sync_binlog=0 时，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1 时，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) 时，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ol>
</li>
<li>将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志（没有持久化到磁盘，主机挂了就丢失了）。</li>
</ol>
<h3 id="redo-log-的写入机制"><a href="#redo-log-的写入机制" class="headerlink" title="redo log 的写入机制"></a>redo log 的写入机制</h3><p><img data-src="http://cdn.chaohang.top/20200529173305.png" alt=""></p>
<ol>
<li>事务在执行过程中，生成的 redo log 会先写到 redo log buffer 中。</li>
<li>写入到 page cache 的速度也很快，写入到磁盘的速度慢。</li>
<li><code>innodb_flush_log_at_trx_commit</code> 参数用来控制 redo log 的写入策略：<ol>
<li>设为 0 时，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中；</li>
<li>设为 1 时，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设为 2 时，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
</li>
<li>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</li>
<li>事务执行过程中写入 redo log buffer 的记录，也会随着其他事务的提交或者定时写入过程持久化到磁盘中。也就是说有些还未提交的事务的 redo log 也会被持久化。</li>
<li>redo log buffer 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，也会触发持久化操作。</li>
</ol>
<h3 id="分组提交"><a href="#分组提交" class="headerlink" title="分组提交"></a>分组提交</h3><p>为了降低写磁盘的次数，redo log 把 write 和 fsync 拆成两个步骤，当有并发时，事务A写完 page cahce，事务B也写完了 page cache，事务A触发 fsync 的时候，会把两个事务的 redo log 并在一组，一起写磁盘。</p>
<p>并且为了能让更多的事务加入同一个组，InnoDB 让 redo log 和 binlog 的 write 和 fsync 交替执行，分组提交的优化，redo log 和 binlog 都有。</p>
<p><img data-src="http://cdn.chaohang.top/20200529175020.png" alt=""></p>
<p><strong>WAL 机制是减少磁盘写，但每次提交事务都要写 redo log 和 binlog，写磁盘的次数好像没有减少？</strong></p>
<ol>
<li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度快；（日志写磁盘都是顺序写的，事务提交后直接把数据写磁盘就是随机访问）；</li>
<li>组提交机制可以大幅降低磁盘的 IOPS 消耗。</li>
</ol>
<h3 id="MySQL-是如何保证-crash-safe-的。"><a href="#MySQL-是如何保证-crash-safe-的。" class="headerlink" title="MySQL 是如何保证 crash-safe 的。"></a>MySQL 是如何保证 crash-safe 的。</h3><p><strong>redo log 是如何保证 crash-safe 的。</strong><br>写到 redo log buffer 不能保证 crash-safe，写到 fs cache 也不能保证 crash-safe，只有 redo log 写入磁盘之后，数据库异常重启，从磁盘中的 redo log 拿出未执行的日志进行恢复，才算是 crash-safe。<br>这也说明了多个事务提交之后才写磁盘，还是会有事务丢失。只有每个事务提交后都进行写磁盘才能保证数据完全不丢失。</p>
<p><strong>binlog 为什么无法保证 crash-safe?</strong></p>
<ol>
<li>如果 binlog 写入成功了，数据还没写入磁盘，数据库异常崩溃，重启后主库没有这部分数据，而通过 binlog 同步的从库却有了这部分配置，导致主从数据不一致。</li>
<li>如果 数据写入磁盘，binlog 写入失败了，数据库异常崩溃，重启后主库有这部分数据，而通过 binlog 同步的从库没有这部分数据，导致主从数据不一致。</li>
</ol>
<p><strong>能否只使用 binlog 或 redo log 单个日志保证 crash-safe?</strong></p>
<p>我的理解是：并不是单个 log 无法保证 crash-safe，而是 binlog 本身无法保证 crash-safe，因为 InnoDB 无法重新设计 binlog，所以引入了 redo log。并且花了很大力气来保证 redo log 和 binlog 的一致性。<br>如果重新设计 MySQL，可以使用 redo log 实现 binlog 的功能，也可以把 binlog 设计成 crash-safe 的，这样就只需要一种 log 了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://time.geekbang.org/column/article/68633" target="_blank" rel="noopener">02 | 日志系统：一条SQL更新语句是如何执行的？-极客时间</a></p>
<p><a href="https://time.geekbang.org/column/article/70848" target="_blank" rel="noopener">09 | 普通索引和唯一索引，应该怎么选择？-极客时间</a></p>
<p><a href="https://time.geekbang.org/column/article/71806" target="_blank" rel="noopener">12 | 为什么我的MySQL会”抖”一下？-极客时间</a></p>
<p><a href="https://time.geekbang.org/column/article/73161" target="_blank" rel="noopener">15 | 答疑文章（一）：日志和索引相关问题-极客时间</a></p>
<p><a href="https://time.geekbang.org/column/article/76161" target="_blank" rel="noopener">23 | MySQL是怎么保证数据不丢的？-极客时间</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者 <a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>公众号【超超不会飞】</p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>早起实操手册</title>
    <url>/2020/05/07/%E6%97%A9%E8%B5%B7%E5%AE%9E%E6%93%8D%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812112441.jpg" alt=""></p>
<p>从2019年大概11月份左右，我开始尝试早起，一直坚持到现在已经有半年左右了。目前工作日和周日5点45分或者6点20分左右起床，具体时间看昨晚的入睡时间。周六关闭闹钟靠生物钟起床。</p>
<a id="more"></a>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最初的起因很偶然——女朋友考研到了冲刺阶段，每天5点起床背书，我想着干脆我也陪着早起，一起学习，这样女朋友就不用担心吵醒我了。</p>
<h3 id="初期问与答"><a href="#初期问与答" class="headerlink" title="初期问与答"></a>初期问与答</h3><ol>
<li><p>如何激励自己的？</p>
<p> 我给自己画了一个表格，每次早起就打个勾勾，看着勾勾越来越多，很有成就感。我还约定每次早起就奖励5块钱，这些钱攒起来可以买自己喜欢的。</p>
<p> 小贴士：最好是实体的表格，拿张4A纸，自己手绘的表格，贴在墙上，每天看着很有成就感。</p>
</li>
<li><p>早起做什么？</p>
<p> 刚开始早起的时候，我并没有想好自己要做什么。我就想着早起就好了，先养成习惯，一开始可以开心一点，我在前半个月左右都是看小说，那段时间看完了《谷歌方法》。</p>
</li>
<li><p>困了怎么办？</p>
<p> 喝咖啡啊！从一开始的普通速溶咖啡，到一勺黑咖啡，到两勺黑咖啡。现在几乎每天早起都是先来一杯咖啡，不过下午就不能喝了，怕晚上睡不着。</p>
</li>
<li><p>早起高效吗？</p>
<p> 我是属于早晨专注度特别高，思路也清晰，学习效率高的那种。一到晚上就想睡觉，没办法思考复杂的问题。不过这个因人而异，尝试出真知。</p>
</li>
<li><p>这么早起，晚上要几点睡？</p>
<p> 早起倒逼自己早睡！</p>
<p> 比如早上6点起床，需要晚上10点睡觉才能睡满8个小时。我一般晚上10点半到11点左右睡觉，如果遇到有什么事情晚了也没事，照样早起，睡眠质量好才是关键，睡眠质量不好即使睡满8个小时，白天也困。</p>
<p> 先早起，到晚上自然而然就困了，不存在什么晚上睡不着的幺蛾子。</p>
</li>
<li><p>早晨关掉闹钟倒下继续睡怎么办？</p>
<p> 刚开始这个习惯的时候我有天然的地理优势——我住的loft小公寓，二楼只有床，一楼是生活区——手机在楼下，闹钟一响我就下楼关手机，自然就离开床了。后来搬家，住在只有床的小房间，关了闹钟屁股后面就是床，导致那段时间早起规律很受影响。</p>
<p> 小贴士：尽量把手机放远点，起床关闹钟，起床了就去烧水洗漱干别的事情。</p>
</li>
</ol>
<h3 id="平衡生活与工作"><a href="#平衡生活与工作" class="headerlink" title="平衡生活与工作"></a>平衡生活与工作</h3><ol>
<li><p>早上想做饭怎么办？</p>
<p> 我一般带饭到公司，不想吃隔夜的饭菜，只能在早晨做。晚上把菜和肉都切好洗好，把米洗好放电饭煲，起床第一件事，烧水+电饭煲点开始煮饭。泡杯咖啡先学习一个小时再开始做饭，半个小时搞定。</p>
</li>
<li><p>晚上公司加班怎么办？</p>
<p> 一开始我们公司是不加班的，我每天大概7点下班，8点到家，收拾好后还能休闲一下再睡觉。过年回来后，借着疫情这个借口，公司开始强推1095，每天晚上必须9点才可以下班。</p>
<p> 因为我早上到公司比较早（大概8点半到了，公司规定10点上班），晚上我就弹性一点，8点左右开溜，到家9点，洗漱完困了就直接睡觉，不困的话就玩两局游戏，也能保持在11点左右睡觉。</p>
</li>
<li><p>晚上回家还要洗衣服，洗碗，切菜做饭怎么办？</p>
<p> 回家早的话还好，回家晚的话就不行了。这时候就要夸夸我可爱的女朋友了，承包了洗碗和切菜的业务，让我晚上回家可以直接洗漱，不用操心其他事情。</p>
</li>
<li><p>抖音快手刷着刷着就凌晨2点了，怎么办？</p>
<p> 人不要与算法作斗争，赢不了的，卸载完事。Bilibili不香吗？</p>
</li>
</ol>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>每天早晨都有实打实的一个小时学习时间，利用这个时间我看了一些想看的书，刷了买了没来得及看的极客时间课程（刚刷完《数据结构与算法之美》），难度大的学习内容特别适合放在早上，一天最清醒的时间里学习。</p>
<p>早上有时间做饭，在家和女朋友一起吃早餐，享受清晨的阳光、清新的空气和啾啾啾的鸟叫声。</p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者 <a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>公众号【超超不会飞】</p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机3——垃圾回收</title>
    <url>/2020/02/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA3%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812112333.jpg" alt=""></p>
<blockquote>
<p>《深入理解Java虚拟机》第3章读书笔记</p>
</blockquote>
<a id="more"></a>
<p>本文介绍了如何判断对象是否存活，三种垃圾回收算法，分析比较了几种垃圾收集器的特点。本文并非原创，是《深入理解Java虚拟机》第3章的整理、总结和补充。</p>
<h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><p>垃圾收集器在对堆进行回收前，要先判断哪些对象“存活”，哪些已经“死去”。</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>主流的Java虚拟机里面没有选用引用计数算法来管理内存。</p>
<p>优点：实现简单，效率高。</p>
<p>缺点：很难解决对象之间相互循环引用的问题。</p>
<p>循环引用问题，如下代码所示，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 源代码出自《深入理解Java虚拟机》P62-63</span></span><br><span class="line"><span class="comment"> * 循环引用</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行参数</span></span><br><span class="line"><span class="comment">     * -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM参数设置了新生代为10MB，运行结果显示，在第一次触发GC时，“5120K-&gt;576K(9216K)”回收了约4MB内存。意味着虚拟机并没有因为两个对象相互引用就不回收它们，这也侧面说明了虚拟机并不是通过引用计数算法来判断对象是否存活</p>
<p><img data-src="http://cdn.chaohang.top/20200227072300.png" alt=""></p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>如图，object5、object6、object7 为可回收对象</p>
<p><img data-src="http://cdn.chaohang.top/20200227073303.png" alt=""></p>
<p>主流的Java虚拟机使用可达性分析算法</p>
<p>在Java语言中，GC Roots包括以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中Native方法引用的对象</li>
</ul>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><ol>
<li>强引用：代码中普遍存在，垃圾收集器不会回收强引用的对象。</li>
<li>软引用：有用但非必需，在系统将要发生内存溢出异常之前，会把这些对象列入回收范围。</li>
<li>弱引用：非必需，无论当前内存是否足够，下次垃圾回收都会回收掉这些对象。</li>
<li>虚引用：最弱的引用关系，是否有虚引用不对其生存时间构成影响。</li>
</ol>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>最基础的收集算法——“标记-清除”(Mark-Sweep)算法。一般用于老年代。</p>
<p>算法分为“标记”和“清除”两个阶段：</p>
<ol>
<li>标记出需要回收的对象</li>
<li>清除被标记的对象</li>
</ol>
<p>缺点：效率低，空间碎片化。</p>
<p><img data-src="http://cdn.chaohang.top/20200227074938.png" alt=""></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，出现了“复制”算法(Copying)。它将内存分为两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>缺点：内存缩小为原来的一半。</p>
<p><img data-src="http://cdn.chaohang.top/20200227075507.png" alt=""></p>
<p>JVM虚拟机在新生代使用这种收集算法，并不是按照 1:1 的比例来划分内存空间。而是根据新生代中的对象98%是“朝生夕死”这一特点，将内存分为一块较大的 Eden(80%) 空间和两块较小的 Survivor(10%) 空间。每次只使用 Eden 和其中一块 Survivor，当回收时，将 Eden 和 Survivor 中还存活的对象，一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</p>
<p>HotSpot默认Eden和Survivor的大小比例为8:1，这样就只有10%的内存被“浪费”。当出现超过10%的对象存活时，就会使用老年代做分配担保，把Survivor空间放不下的对象，直接放入老年代。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>在Mark-Sweep算法的基础上做了改良，用于解决空间碎片化问题。标记-整理(Mark-Compact)算法在标记后不是简单做清除，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。一般用于老年代。</p>
<p><img data-src="http://cdn.chaohang.top/20200227080944.png" alt=""></p>
<h2 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>在做可达性分析时，需要保持分析期间整个系统不会发生变化，这就导致GC进行时必须停顿所有Java执行线程(Stop The World)，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也必须要停顿。</p>
<p>程序执行时并非在所有地方都能停下来开始GC，只有在到达<strong>安全点(Safepoint)</strong>时才能暂停。Safepoint 的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，例如方法调用，循环跳转，异常跳转等。</p>
<p>如何在GC发生时让线程都跑到最近的安全点再停顿下来？</p>
<ul>
<li>抢先试中断：先把所有线程中断，发现不在安全点的线程恢复线程，让它跑到安全点。</li>
<li>主动式中断：设置一个不可读的内存位置作为中断标志，标志与安全点重合，当线程执行到这个标志时自己中断挂起。</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域(Safe Region)是指在一段代码片段中，引用关系不会发生变化。在这个区域的任何地方开始GC都是安全的。典型的安全区域比如线程处于Sleep状态或者Blocked状态。</p>
<p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region。当要发起GC时，就不用管标识为Safe Region状态的线程了。当线程要离开Safe Region时，要检查是否处于GC状态，如果是，就要继续等待，直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul>
<li>并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li>
</ul>
<p><img data-src="http://cdn.chaohang.top/20200611090920.png" alt=""></p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即</p>
<p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。</p>
<p>假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul>
<li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC 非常频繁，一般回收速度也比较快。</li>
<li>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h3 id="HotSpot虚拟机的垃圾收集器对比"><a href="#HotSpot虚拟机的垃圾收集器对比" class="headerlink" title="HotSpot虚拟机的垃圾收集器对比"></a>HotSpot虚拟机的垃圾收集器对比</h3><p><img data-src="http://cdn.chaohang.top/20200115143022.png" alt=""></p>
<table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行、并发</th>
<th>新生代、老生代</th>
<th>算法</th>
<th>目标</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>单线程，串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Serial Old</td>
<td>单线程，串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后</td>
</tr>
<tr>
<td>ParNew</td>
<td>多线程，并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td>Parallel Scanvenge</td>
<td>多线程，并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>多线程，并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td>G1</td>
<td>并发</td>
<td>both</td>
<td>复制算法+标记-整理</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody>
</table>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>Serial收集器的多线程版本，Service模式下的首选新生代收集器，除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p>
<p>ParNew 收集器是使用 <code>-XX:+UseConcMarkSweepGC</code> 选项后的默认新生代收集器，也可以使用 <code>-XX:+UseParNewGC</code> 选项来强制指定它。</p>
<p>运行示意图如下：</p>
<p><img data-src="http://cdn.chaohang.top/20200228063445.png" alt=""></p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。基于Mark-Sweep算法。运行过程分为四个部分：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>其中，初始标记和重新标记仍然需要 Stop The World。初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快。并发标记就是进行 GC Roots Tracing 的过程，而重新标记阶段则是为了修正并发标记期间用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间比初始标记稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清楚过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>运行示意图如下：</p>
<p><img data-src="http://cdn.chaohang.top/20200228064903.png" alt=""></p>
<p>CMS 收集器有如下3个缺点：</p>
<ol>
<li><p>对CPU资源非常敏感</p>
<p>因为并发阶段需要占用一个用户线程，如果CPU小于4个，则会导致用户程序的执行速度下降大于25%，如果只有2个CPU，用户程序执行速度则会下降50%，这是让人无法接收的。一般来说使用CMS收集器的服务器配置至少需要4个CPU。</p>
</li>
<li><p>无法处理浮动垃圾</p>
<p>在并发清理过程中产生的垃圾称为“浮动垃圾”。这些垃圾只能等待下次垃圾回收。因此，CMS 收集器不能像其他收集器那样等到老年代几乎被完全填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</p>
</li>
<li><p>内存空间碎片化</p>
<p>CMS 收集器是基于Mark-Sweep算法，这个算法会产生内存空间碎片。CMS 收集器提供了一个 <code>-XX:+UseCMSCompactAtFullCollection</code> 开关参数（默认为开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。内存整理的过程是无法并发执行的，空间碎片问题没有了，但停顿时间不得不变长。</p>
</li>
</ol>
<h3 id="使用多个收集器配置，JVM会怎么处理？"><a href="#使用多个收集器配置，JVM会怎么处理？" class="headerlink" title="使用多个收集器配置，JVM会怎么处理？"></a>使用多个收集器配置，JVM会怎么处理？</h3><p>如果同时使用了四个组合配置，这时候就会报错</p>
<p><img data-src="http://cdn.chaohang.top/20200115143855.png" alt=""></p>
<p><img data-src="http://cdn.chaohang.top/20200115143950.png" alt=""></p>
<p>但是比如 <code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code> 这两个配置同时存在就不会报错。</p>
<p>翻看源码可知</p>
<p><img data-src="http://cdn.chaohang.top/20200115154156.png" alt=""></p>
<p>有些配置项是可以并存的。</p>
<p>其实，在使用 <code>UseConcMarkSweepGC</code> 配置的时候，虚拟机默认开启了 <code>UseParNewGC</code></p>
<p><img data-src="http://cdn.chaohang.top/20200115154535.png" alt=""></p>
<p>所以在配置JVM时，我们尽量显式配置。比如要启用 ParNew + CMS 组合可以配置为</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure>
<h2 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h2><p><img data-src="http://cdn.chaohang.top/20200228071137.png" alt=""></p>
<h2 id="《深入理解Java虚拟机》阅读笔记系列"><a href="#《深入理解Java虚拟机》阅读笔记系列" class="headerlink" title="《深入理解Java虚拟机》阅读笔记系列"></a>《深入理解Java虚拟机》阅读笔记系列</h2><p><a href="https://chaohang.top/2020/02/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" target="_blank" rel="noopener">深入理解Java虚拟机1——内存区域</a></p>
<p><a href="https://chaohang.top/2020/02/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/" target="_blank" rel="noopener">深入理解Java虚拟机2——对象探秘</a></p>
<p><a href="https://chaohang.top/2020/02/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA3%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" target="_blank" rel="noopener">深入理解Java虚拟机3——垃圾回收</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者 <a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>公众号【超超不会飞】</p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>阅读</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机2——对象探秘</title>
    <url>/2020/02/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812112359.jpg" alt=""></p>
<blockquote>
<p>《深入理解Java虚拟机》第2章读书笔记</p>
</blockquote>
<a id="more"></a>
<p>本文介绍对象的创建过程，包括如何对内存进行分配和对象中内存的布局，还介绍了如何访问对象。本文并非原创，是《深入理解Java虚拟机》第2章的整理、总结和补充。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img data-src="http://cdn.chaohang.top/20200224075442.png" alt=""></p>
<p><strong>堆内存的分配取决于内存是否规整：</strong></p>
<ul>
<li><p>如果使用 Serial, ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是<strong>指针碰撞(Bump the Pointer)</strong>——假设内存绝对规整，所有用过的内存都在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间挪动一段与对象大小相等的距离；</p>
</li>
<li><p>而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用<strong>空闲列表(Free List)</strong>——如果内存不规整，已使用的和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p>
</li>
</ul>
<p>对象的创建是非常频繁的，可能出现正在给A对象分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<strong>如何保证并发下线程安全，有两种方案：</strong></p>
<ul>
<li><p>对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；</p>
</li>
<li><p>把分配内存的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定；</p>
</li>
<li><p>虚拟机是否使用 TLAB，可以通过-XX:+/-UseTLAB 参数来设定。</p>
</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 HotSpot 虚拟机中，对象在内存中存储的布局分为3个区域：</p>
<ul>
<li>对象头(Header)</li>
<li>实例数据(Instance Data)</li>
<li>对齐填充(Padding)</li>
</ul>
<p><strong>对象头包括两部分信息</strong>：</p>
<ul>
<li>用于存储对象自身的运行时数据：哈希码，GC分代年龄，锁状态标志等；</li>
<li>类型指针：对象指向它的类元数据的指针。如果对象是一个Java数组，那在对象头还必须有一块用于记录数据长度的数据。</li>
</ul>
<p><strong>实例数据部分</strong>是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。</p>
<p><strong>对齐填充并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用</strong>。因为 HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8的整数倍。而对象头刚好是8的整数倍，因此，当对象实例数据没有对齐时，就需要对齐填充来补全。</p>
<h2 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h2><p>目前有两种主流的访问方式：</p>
<p><strong>句柄访问</strong>：Java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了<strong>对象实例数据</strong>(Java堆)与<strong>类型数据</strong>(方法区)各自的具体地址信息。</p>
<p><img data-src="http://cdn.chaohang.top/20200225071106.png" alt=""></p>
<p><strong>直接指针访问</strong>：reference中存储的直接就是<strong>实例对象</strong>(Java堆)的地址，由对象实例数据来存放指向<strong>对象类型数据</strong>(方法区)的指针。</p>
<p><img data-src="http://cdn.chaohang.top/20200225071846.png" alt=""></p>
<p><strong>句柄访问的优势</strong>：reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身无需修改。</p>
<p><strong>直接指针访问的优势</strong>：速度快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，这类开销积少成多后也是非常可观的执行成本。</p>
<p>HotSpot 使用的是直接指针访问。</p>
<h2 id="《深入理解Java虚拟机》阅读笔记系列"><a href="#《深入理解Java虚拟机》阅读笔记系列" class="headerlink" title="《深入理解Java虚拟机》阅读笔记系列"></a>《深入理解Java虚拟机》阅读笔记系列</h2><p><a href="https://chaohang.top/2020/02/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" target="_blank" rel="noopener">深入理解Java虚拟机1——内存区域</a></p>
<p><a href="https://chaohang.top/2020/02/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/" target="_blank" rel="noopener">深入理解Java虚拟机2——对象探秘</a></p>
<p><a href="https://chaohang.top/2020/02/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA3%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" target="_blank" rel="noopener">深入理解Java虚拟机3——垃圾回收</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者 <a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>公众号【超超不会飞】</p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>阅读</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>博客优化小记</title>
    <url>/2020/02/23/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812112717.jpg" alt=""></p>
<p>趁着周末把博客优化了一下，主要优化以下几点：</p>
<ol>
<li>阅读统计和访客统计</li>
<li>添加评论</li>
<li>升级hexo版本和NexT版本</li>
<li>配置SEO</li>
<li>静态文件cdn加速</li>
<li>使用gulp压缩文件</li>
<li>添加lazyload</li>
<li>添加站内搜索</li>
</ol>
<a id="more"></a>
<h2 id="阅读统计和访客统计"><a href="#阅读统计和访客统计" class="headerlink" title="阅读统计和访客统计"></a>阅读统计和访客统计</h2><p>阅读统计和访客统计使用的都是不蒜子，因为使用的是NexT主题，只需要添加一下配置就可以了。</p>
<h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><p>原本评论插件使用的是 disqus，但配置后了之后才发现已经被qi*ang了。改为使用 valine。valine 需要配合 leancloud 用于存储数据。</p>
<p>注意：cleancloud 在创建应用之前，要手动选择华东节点，因为华北节点会报一个 <code>Code : undefined [410 POST https://avoscloud.com/1.1/classes/Comment]</code> 的错误，无法正确加载出评论。</p>
<p><img data-src="http://cdn.chaohang.top/20200222100258.png" alt=""></p>
<h2 id="升级hexo版本和NexT版本"><a href="#升级hexo版本和NexT版本" class="headerlink" title="升级hexo版本和NexT版本"></a>升级hexo版本和NexT版本</h2><p>之前使用的NexT版本是5.1.2，没有自带 valine ，尝试了各种方法想把 valine 相关的代码复制到这个版本里，但结果都不理想，迫不得已只能升级。</p>
<p>升级hexo比较简单，删掉 lock 文件，删掉 node_modules，在 package.json 里直接把版本号改了，重新 yarn install。升级后没有发现兼容性问题。</p>
<p>升级NexT就比较操蛋了，theme 文件是以源代码的形式从 GitHub 上 clone 下来的，没有在原本版本升级的办法。只能重新clone下来一份，再把配置文件手动迁移过去(复制粘贴)，如果之前魔改过 theme 文件，升级简直不要太难。</p>
<p>幸好我之前没有做什么改动和个性化，只需要把原先的配置再重新配置一份就够了。</p>
<h2 id="配置SEO"><a href="#配置SEO" class="headerlink" title="配置SEO"></a>配置SEO</h2><p>基本上是参考下面这篇文章进行配置的，没有遇到什么棘手的问题。对 SEO 的配置对我这种流量为0的博客，怎么说呢，自己开心就好，哈哈哈。</p>
<p><a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo博客Next主题SEO优化方法</a></p>
<h2 id="静态文件cdn加速"><a href="#静态文件cdn加速" class="headerlink" title="静态文件cdn加速"></a>静态文件cdn加速</h2><p>我对博客的一个重要要求，就是访问速度，所有容易拖累访问速度的功能都要思考一下是否必要。所以我的博客一直比较简洁，没有其他花花绿绿的东西，保证速度优先。下面几项都是对访问速度的优化</p>
<p>博客内所使用的图片都是存储在七牛云中的，图片资源无需再优化。这次添加功能引入了不蒜子和 valine，使用 chrome 可以看出这两个 js 文件的加载速度不快。</p>
<p><img data-src="http://cdn.chaohang.top/20200222102536.png" alt=""></p>
<p>所以我把这两个文件单独复制出来，上传到七牛云里，并在博客里引用七牛云的链接。</p>
<p>但是发布上去后出现了 http 请求被浏览器 block 的问题。因为我的主站使用的 https，七牛使用的 http（因为七牛的https不能使用免费流量，穷哭o(╥﹏╥)o）。浏览器不允许https请求http。</p>
<p>机智的我灵机一动，使用 nginx 转发七牛云的请求不就行了。所以我在 nginx.conf 添加了以下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;cdn &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;cdn.chaohang.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 /cdn 目录下的请求全部转发到 cdn.chaohang.top 这个子域名下，比如：</p>
<p><a href="https://chaohang.top/cdn/min.js" target="_blank" rel="noopener">https://chaohang.top/cdn/min.js</a> 会被转发至 <a href="http://cdn.chaohang.top/cdn/min.js" target="_blank" rel="noopener">http://cdn.chaohang.top/cdn/min.js</a></p>
<p>这样子就可以成功绕过浏览器的限制了，因为实际的请求是通过服务器代理的。</p>
<p>Next 官方也提供了一些cdn加速，我们可以在配置文件里配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vendors底下全部都是可使用的cdn</span><br><span class="line">vendors:</span><br><span class="line">  # Internal path prefix.</span><br><span class="line">  _internal: lib</span><br><span class="line"></span><br><span class="line">  # FancyBox</span><br><span class="line">  # jquery: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line">  # fancybox: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;fancyapps&#x2F;fancybox@3&#x2F;dist&#x2F;jquery.fancybox.min.js</span><br><span class="line">  # fancybox_css: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;fancyapps&#x2F;fancybox@3&#x2F;dist&#x2F;jquery.fancybox.min.css</span><br><span class="line">  jquery: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;jquery@3&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line">  fancybox: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;fancyapps&#x2F;fancybox@3&#x2F;dist&#x2F;jquery.fancybox.min.js</span><br><span class="line">  fancybox_css: &#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;fancyapps&#x2F;fancybox@3&#x2F;dist&#x2F;jquery.fancybox.min.css</span><br></pre></td></tr></table></figure>
<h2 id="使用gulp压缩html、css、js"><a href="#使用gulp压缩html、css、js" class="headerlink" title="使用gulp压缩html、css、js"></a>使用gulp压缩html、css、js</h2><p>因为 Next 的版本7.0，使用 next-neat 会有问题，所以我选择使用 gulp 做代码压缩，也方便以后扩展。</p>
<p>安装依赖</p>
<p><code>npm install gulp -g</code></p>
<p><code>npm install gulp-clean-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp gulp-babel gulp-imagemin babel-core babel-preset-es2015</code></p>
<p><code>npm install -D @babel/core</code></p>
<p>安装后的包版本如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line">&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">&quot;canvas-nest.js&quot;: &quot;^2.0.3&quot;,</span><br><span class="line">&quot;core-util-is&quot;: &quot;^1.0.2&quot;,</span><br><span class="line">&quot;gulp&quot;: &quot;^4.0.2&quot;,</span><br><span class="line">&quot;gulp-babel&quot;: &quot;^7.0.0&quot;,</span><br><span class="line">&quot;gulp-clean-css&quot;: &quot;^4.2.0&quot;,</span><br><span class="line">&quot;gulp-htmlclean&quot;: &quot;^2.7.22&quot;,</span><br><span class="line">&quot;gulp-htmlmin&quot;: &quot;^5.0.1&quot;,</span><br><span class="line">&quot;gulp-imagemin&quot;: &quot;^7.1.0&quot;,</span><br><span class="line">&quot;gulp-uglify&quot;: &quot;^3.0.2&quot;,</span><br><span class="line"></span><br><span class="line">&quot;@babel&#x2F;core&quot;: &quot;^7.8.4&quot;</span><br></pre></td></tr></table></figure>
<p>在执行过程中可能会遇到一些包版本问题，如有问题请参照我给出的包版本进行调整。</p>
<p>在项目根目录下新建 <code>gulpfile.js</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">var</span> cleancss = <span class="built_in">require</span>(<span class="string">'gulp-clean-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(cleancss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">html</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyURLs: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">js</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets: [<span class="string">'es2015'</span>]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'css'</span>, css)</span><br><span class="line">gulp.task(<span class="string">'html'</span>, html)</span><br><span class="line">gulp.task(<span class="string">'js'</span>, js)</span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.series(gulp.parallel(<span class="string">'html'</span>, <span class="string">'css'</span>, <span class="string">'js'</span>)));</span><br></pre></td></tr></table></figure>
<p>在生成代码文件后，使用 <code>gulp</code> 命令压缩文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">gulp</span><br></pre></td></tr></table></figure>
<h2 id="添加lazyload"><a href="#添加lazyload" class="headerlink" title="添加lazyload"></a>添加lazyload</h2><p><a href="https://github.com/theme-next/theme-next-jquery-lazyload" target="_blank" rel="noopener">lazylod</a>可以在用户不查看的时候，不加载相关部分，从而提升网站加载速度。</p>
<p>先是在next目录里clone仓库：</p>
<p><code>git clone https://github.com/theme-next/theme-next-jquery-lazyload source/lib/jquery_lazyload</code></p>
<p>再把配置里的开关打开：</p>
<p><code>lazyload: true</code></p>
<h2 id="添加站内搜索"><a href="#添加站内搜索" class="headerlink" title="添加站内搜索"></a>添加站内搜索</h2><p>Next集成了站内搜索功能，可以先安装依赖</p>
<p><code>npm install hexo-generator-searchdb --save</code></p>
<p>然后设置主题配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 3</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>
<p>以上就是全部优化过程了，即使没人访问的站，也要好好的优化，这就是一个工(搬)程(砖)师(工)的坚持。</p>
<p><img data-src="http://cdn.chaohang.top/20200223175103.png" alt=""></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>博客</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机1——内存区域</title>
    <url>/2020/02/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812112424.jpg" alt=""></p>
<blockquote>
<p>《深入理解Java虚拟机》第2章读书笔记</p>
</blockquote>
<a id="more"></a>
<p>本文介绍了JVM内存的各个区域和他们的用途。本文并非原创，是《深入理解Java虚拟机》第2章的整理、总结和补充。</p>
<h2 id="运行时内存区域"><a href="#运行时内存区域" class="headerlink" title="运行时内存区域"></a>运行时内存区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p>
<p>下图为《Java虚拟机规范》规定的几个区域，不同虚拟机实现起来略有区别：</p>
<p><img data-src="http://cdn.chaohang.top/20200220081746.jpg" alt="内存区域"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p>保存线程当前工作状态。</p>
</blockquote>
<p>程序计数器（Program Counter Register）是一块<strong>较小</strong>的内存空间，它可以看做是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于<strong>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的</strong>，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器</strong>，各线程之间计数器互不影响，独立存储，我们称这类内存区域<strong>为“线程私有”的内存</strong>。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。</p>
<p>如果正在执行的是Native方法，这个计数器值则为空（Undefined）。</p>
<p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</strong></p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><blockquote>
<p>每个方法执行时都会创建一个栈帧，栈帧里有个局部变量表存储着基本数据类型和对象引用。</p>
</blockquote>
<p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。</p>
<p>虚拟机栈描述的是Java<strong>方法执行</strong>的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>Java内存经常被粗糙的分为堆内存和栈内存，其中栈内存就是指的虚拟机栈。</p>
<p>局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAdress类型。</p>
<p>其中64位的 long 和 double 类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p>
<p>局部变量表所需的内存空间在编译期间内完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>如果请求的栈深度大于虚拟机所允许的深度（比如无限深度的递归），将抛出 <code>StackOverflowError</code> 异常；如果虚拟机栈可以动态扩展（大部分虚拟机都可以），如果无法申请到足够的内存，就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p>与虚拟机栈相似，只是为Native方法服务。</p>
</blockquote>
<p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。本地方法栈则为虚拟机使用到的Native方法服务。</p>
<p>在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构没有强制规定，虚拟机可以自由实现它，甚至可以把本地方法栈和虚拟机栈合二为一。</p>
<p>和Java虚拟机栈一样，也会抛出<code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote>
<p>存放对象实例，GC主要管理的区域。</p>
</blockquote>
<p>Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。</p>
<p>Java堆是垃圾收集器管理的主要区域，也被称为“GC堆”。</p>
<p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。堆的内存大小是可扩展的（通过-Xmx 和 -Xms）。</p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将抛出 <code>OutOfMemoryError</code> 异常</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>存储类信息，常量，静态变量，JIT代码。JDK1.8中HotSpot用元空间(MetaSpace)取代永久代。</p>
</blockquote>
<p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（不容易发生变化的数据）。</p>
<p>方法区也被称为永久代（诨名），因为这个区域可以选择不实现垃圾收集。但大部分虚拟机还是会实现垃圾收集，只是回收的条件极为苛刻。</p>
<p>当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>缓冲区Buffer使用的堆外内存，它可以使用native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了Java虚拟机内存中的几个区域，分别介绍了不同区域各自的作用和特点。</p>
<p>线程隔离的区域：</p>
<ul>
<li>程序计数器：保存线程当前工作状态。</li>
<li>Java虚拟机栈：每个方法执行时都会创建一个栈帧，栈帧里有个局部变量表存储着基本数据类型和对象引用。</li>
<li>本地方法栈：与虚拟机栈相似，只是为Native方法服务。</li>
</ul>
<p>线程共享的区域：</p>
<ul>
<li>Java堆：存放对象实例，GC主要管理的区域。</li>
<li>方法区：存储类信息，常量，静态变量，JIT代码。</li>
</ul>
<h2 id="《深入理解Java虚拟机》阅读笔记系列"><a href="#《深入理解Java虚拟机》阅读笔记系列" class="headerlink" title="《深入理解Java虚拟机》阅读笔记系列"></a>《深入理解Java虚拟机》阅读笔记系列</h2><p><a href="https://chaohang.top/2020/02/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA1%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" target="_blank" rel="noopener">深入理解Java虚拟机1——内存区域</a></p>
<p><a href="https://chaohang.top/2020/02/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA2%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/" target="_blank" rel="noopener">深入理解Java虚拟机2——对象探秘</a></p>
<p><a href="https://chaohang.top/2020/02/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA3%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" target="_blank" rel="noopener">深入理解Java虚拟机3——垃圾回收</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者 <a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>公众号【超超不会飞】</p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>阅读</tag>
        <tag>JVM</tag>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Java源码系列3——LinkedHashMap</title>
    <url>/2020/02/16/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94LinkedHashMap/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812105955.jpg" alt=""></p>
<h2 id="什么是LinkedHashMap？"><a href="#什么是LinkedHashMap？" class="headerlink" title="什么是LinkedHashMap？"></a>什么是LinkedHashMap？</h2><p><code>LinkedHashMap</code> 是 <code>HashMap</code> 的有序实现。<code>LinkedHashMap</code> 用一条双向链表来维护顺序，迭代的时候也使用自己实现的迭代器。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; h = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">33</span>);</span><br><span class="line">    h.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">    h.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">    h.put(<span class="string">"three"</span>, <span class="number">3</span>);</span><br><span class="line">    h.put(<span class="string">"four"</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : h.keySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span> + key + <span class="string">"value:"</span> + h.get(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LinkedHashMap&lt;String, Integer&gt; lh = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">33</span>);</span><br><span class="line">    lh.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">    lh.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">    lh.put(<span class="string">"three"</span>, <span class="number">3</span>);</span><br><span class="line">    lh.put(<span class="string">"four"</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : lh.keySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span> + key + <span class="string">"value:"</span> + lh.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key:twovalue:2</span><br><span class="line">key:threevalue:3</span><br><span class="line">key:fourvalue:4</span><br><span class="line">key:onevalue:1</span><br><span class="line"></span><br><span class="line">key:onevalue:1</span><br><span class="line">key:twovalue:2</span><br><span class="line">key:threevalue:3</span><br><span class="line">key:fourvalue:4</span><br></pre></td></tr></table></figure></p>
<h2 id="底层数组结构"><a href="#底层数组结构" class="headerlink" title="底层数组结构"></a>底层数组结构</h2><p>HashMap的底层是由数组，链表，红黑树组成的。数组用来存储节点，当出现哈希碰撞时使用链表存储，当链表超过一定长度后会优化成红黑树。</p>
<p><img data-src="http://cdn.chaohang.top/20200216153655.png" alt=""></p>
<p>LinkedHashMap 的底层除了继承自 HashMap 的数组，链表，红黑树，还多了链接所有节点的双向链表（图中红色和绿色箭头），用于存储各个节点的顺序。</p>
<p><img data-src="http://cdn.chaohang.top/20200216153931.png" alt=""></p>
<h2 id="Entry的继承关系"><a href="#Entry的继承关系" class="headerlink" title="Entry的继承关系"></a>Entry的继承关系</h2><p><code>LinkedHashMap.Entry</code> 继承了 <code>HashMap.Node</code>，多维护了 before 和 after 两个指针，这两个属性指向该Entry的前一个Entry和后一个Entry，也就是那条用于存储顺序的双向链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 LinkedHashMap 中确没有覆写 HashMap 中 TreeNode 的代码，那红黑树中各个节点的顺序是如何存储的。</p>
<p>我们可以从 <code>HashMap.TreeNode</code> 的继承关系中找出端倪：</p>
<p><img data-src="http://cdn.chaohang.top/20200216144036.png" alt=""></p>
<p>呦吼，这一小家子也真够乱的，子类继承了父类的内部类，父类的内部类又继承了子类的内部类，上演一出鸡生蛋，蛋生鸡的戏码。</p>
<p><img data-src="http://cdn.chaohang.top/20200216145203.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承了 LinkedHashMap.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么 <code>HashMap.TreeNode</code> 要继承 <code>LinkedHashMap.Entry</code>，继承过来的 before 和 after 指针在 HashMap 中也没有被用到，何不直接继承 <code>HashMap.Node</code>？</p>
<p>这样的继承关系其实并不是为 HashMap 设计的，在 HashMap 中确实没什么用。但在 LinkedHashMap 中，就可以直接使用继承过来的 <code>HashMap.TreeNode</code>，因为 TreeNode 这个类通过继承已经拥有了 before 和 after 指针。</p>
<p>这就是为什么，<code>LinkedHashMap</code> 中有一个继承了 <code>HashMap.Node</code> 的内部类，却没有继承 <code>HashMap.TreeNode</code> 的内部类。</p>
<h2 id="链表的创建过程"><a href="#链表的创建过程" class="headerlink" title="链表的创建过程"></a>链表的创建过程</h2><p>链表的创建过程是在第一个元素插入的时候才开始的，一开始链表的头部(head)和尾巴(tail)都为null。</p>
<p><code>LinkedHashMap</code> 没有覆写父类的put方法，元素的插入流程基本相同，只是 <code>HashMap</code> 插入的是 <code>Node</code> 类型的节点，<code>LinkedHashMap</code> 插入的是 <code>Entry</code> 类型的节点，并且更新链表。</p>
<p>那么 <code>LinkedHashMap</code> 是怎么插入节点，并且更新链表的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 桶为空时初始化桶</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 取模得到节点在桶中的索引位置，并且该位置没有元素，直接插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 哈希碰撞了，本节不介绍，可以看上一篇讲 HashMap 的文章</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ... 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现的 newNode</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写的 newNode</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">// 如果链表为空，头部和尾部都赋值为p</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="comment">// 把新插入的节点放在链表尾部</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里可以很明显的看出，LinkedHashMap 中索引的计算，桶的赋值，哈希碰撞时链表或者红黑树的创建，都使用的 HashMap 的实现。LinkedHashMap 只需要覆写节点的创建，并且在创建节点的时候，更新储存顺序的链表。真的是把复用利用到了极致。</p>
<h2 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h2><p>与插入操作一样，LinkedHashMap 也是使用的父类的删除操作，然后覆写了回调方法 <code>afterNodeRemoval</code>，用于维护双向链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ... 省略部分代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 删除后回调</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果b为空，则为头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// 如果a为空，则为尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问顺序的维护"><a href="#访问顺序的维护" class="headerlink" title="访问顺序的维护"></a>访问顺序的维护</h2><p>如果我们在初始化 LinkedHashMap 时，把 accessOrder 参数设为 true，那么我们不仅在插入的时候会维护链表，在访问节点的时候也会维护链表。</p>
<p>当我们调用 <code>get, getOrDefault, replace</code> 等方法时，会更新链表，把访问的节点移动到链表尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 调用了 HashMap 中的 getNode 方法</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果accessOrder为true，调用afterNodeAccess</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 如果本来就在尾部，就不需要更新</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果b为空，则为头部</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="comment">// 尾部不会为空，不知为何要多一个判断</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把尾部赋值为p</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用测试代码体验一下效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap&lt;String, Integer&gt; lh = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">33</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    lh.put(<span class="string">"one"</span>, <span class="number">1</span>);</span><br><span class="line">    lh.put(<span class="string">"two"</span>, <span class="number">2</span>);</span><br><span class="line">    lh.put(<span class="string">"three"</span>, <span class="number">3</span>);</span><br><span class="line">    lh.put(<span class="string">"four"</span>, <span class="number">4</span>);</span><br><span class="line">    lh.get(<span class="string">"two"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : lh.keySet()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span> + key + <span class="string">"value:"</span> + lh.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>竟然报错了</p>
<p><img data-src="http://cdn.chaohang.top/20200216171751.png" alt=""></p>
<p>看一下 LinkedHashMap 覆写的迭代器代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    current = e;</span><br><span class="line">    next = e.after;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ConcurrentModificationException</code> 这个报错是为了防止并发条件下，遍历的同时链表发生变化。因为我们在遍历的时候又调用了 get 方法，导致链表发生变化，才会抛这个错。</p>
<p>accessOrder 为 true 时的正确遍历姿势如下，使用 LinkedHashMap 覆写<code>forEach</code> 方法，就不会在读取值的时候修改顺序链表了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lh.forEach((String k, Integer v) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"key:"</span> + k + <span class="string">", value:"</span> + v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用-LinkedHashMap-实现简单的-LRU"><a href="#使用-LinkedHashMap-实现简单的-LRU" class="headerlink" title="使用 LinkedHashMap 实现简单的 LRU"></a>使用 LinkedHashMap 实现简单的 LRU</h2><blockquote>
<p>LRU 全称 Least Recently Used，也就是最近最少使用的意思，是一种内存管理算法，该算法最早应用于 Linux 操作系统。</p>
<p>这个算法基于一种假设：长期不被使用的数据，在未来被用到的几率也不大。因此，当数据所占内存达到一定阈值时，我们要移除最近最少被使用的数据。</p>
</blockquote>
<p>下面我们介绍一下前置知识。</p>
<p><code>afterNodeInsertion</code> 是一个回调方法，在插入元素的时候回调。LinkedHashMap 覆写了这个方法，主要用来判断是否需要将链表的 head 移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 根据条件判断是否移除链表的head节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中实现，默认返回false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们将继承 LinkedHashMap，通过覆写 <code>removeEldestEntry</code>，达到当 Map 的节点个数超过指定阈值时，删除最少访问的节点。从而实现 LRU 缓存策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NODE_NUM = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(MAX_NODE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleCache</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(limit, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断节点数是否超出限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleCache&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> SimpleCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cache.put(i, i * i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"插入10个键值对后，缓存内容："</span>);</span><br><span class="line">        System.out.println(cache);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"访问键值为7的节点后，缓存的内容："</span>);</span><br><span class="line">        cache.get(<span class="number">7</span>);</span><br><span class="line">        System.out.println(cache);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"插入键值为1的键值对后，缓存的内容："</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：<br><img data-src="http://cdn.chaohang.top/20200216191354.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文围绕 LinkedHashMap 如何维护存储顺序的双向链表展开，介绍了 LinkedHashMap 和 HashMap 节点类的继承关系，介绍了新增，删除，访问时，LinkedHashMap 如何在复用 HashMap 的同时，维护双向链表。最后通过继承 LinkedHashMap 很简单的实现了 LRU 缓存策略。</p>
<p>全文的代码量较多，但都较为好理解。理解JDK的设计思路，探寻背后的实现原理，也是一件很有趣的事。</p>
<blockquote>
<p>本文讨论的源代码都基于JDK1.8版本。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000012964859" target="_blank" rel="noopener">LinkedHashMap 源码详细分析（JDK1.8）</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1183299" target="_blank" rel="noopener">【Java入门提高篇】Day28 Java容器类详解（十）LinkedHashMap详解</a></p>
<h2 id="源码系列文章"><a href="#源码系列文章" class="headerlink" title="源码系列文章"></a>源码系列文章</h2><p><a href="https://chaohang.top/2020/02/11/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94ArrayList/" target="_blank" rel="noopener">Java源码系列1——ArrayList</a></p>
<p><a href="https://chaohang.top/2020/02/12/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94HashMap/" target="_blank" rel="noopener">Java源码系列2——HashMap</a></p>
<p><a href="https://chaohang.top/2020/02/16/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94LinkedHashMap/" target="_blank" rel="noopener">Java源码系列3——LinkedHashMap</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java源码系列2——HashMap</title>
    <url>/2020/02/12/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94HashMap/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812105955.jpg" alt=""></p>
<p><code>HashMap</code> 的源码很多也很复杂，本文只是摘取简单常用的部分代码进行分析。能力有限，欢迎指正。</p>
<a id="more"></a>
<h2 id="HASH-值的计算"><a href="#HASH-值的计算" class="headerlink" title="HASH 值的计算"></a>HASH 值的计算</h2><h3 id="前置知识——位运算"><a href="#前置知识——位运算" class="headerlink" title="前置知识——位运算"></a>前置知识——位运算</h3><p>按位异或操作符<code>^</code>：1^1=0, 0^0=0, 1^0=1, 值相同为0，值不同为1。按位异或就是对二进制中的每一位进行异或运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1111 0000 1111 1110</span><br><span class="line">^  1111 1111 0000 1111</span><br><span class="line">______________________</span><br><span class="line">   0000 1111 1111 0001</span><br></pre></td></tr></table></figure>
<p>按位右移补零操作符<code>&gt;&gt;&gt;</code>：左操作数按右操作数指定的位数右移，移动得到的空位以零填充。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        1110 1101 1001 1111</span><br><span class="line">&gt;&gt;&gt; 4  </span><br><span class="line">___________________________</span><br><span class="line">        0000 1110 1101 1001</span><br></pre></td></tr></table></figure>
<h3 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h3><h4 id="为什么要做扰动？"><a href="#为什么要做扰动？" class="headerlink" title="为什么要做扰动？"></a>为什么要做扰动？</h4><p>理论上哈希值是一个<code>int</code>类型，如果直接拿哈希值做下标的话，考虑到2进制32位带符号的int表值范围从-2147483648到2147483648。前后加起来大概40亿的映射空间。这么大的数组，内存是存不下的，所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>
<p>因为只取最后几位，所以哈希碰撞的可能性大大增加，这时候扰动函数的价值就来了。</p>
<h4 id="扰动计算"><a href="#扰动计算" class="headerlink" title="扰动计算"></a>扰动计算</h4><p><img data-src="http://cdn.chaohang.top/20200119175532.jpg" alt=""></p>
<p>先调用<code>hashCode()</code>方法得出hash值，再进行扰动操作。</p>
<p>右位移16位，正好是32bit的一半（<code>int</code> 是32位的），自己的高半区和低半区做异或，就是为了<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也变相保留下来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取模，计算出下标"><a href="#取模，计算出下标" class="headerlink" title="取模，计算出下标"></a>取模，计算出下标</h3><p>在计算下标的时候，让列表长度对哈希值做取模操作，让计算出来的哈希值在列表范围内，n 为<code>list</code>长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
<h4 id="为什么HashMap的数组长度要取2的整次幂"><a href="#为什么HashMap的数组长度要取2的整次幂" class="headerlink" title="为什么HashMap的数组长度要取2的整次幂"></a>为什么<code>HashMap</code>的数组长度要取2的整次幂</h4><p>因为这样（数组长度 - 1）正好相当于一个“<strong>低位掩码</strong>”。<code>&amp;</code>操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组的下标访问。以初始长度16为例，16-1=15，2进制表示是0000 1111。和某散列值做<code>&amp;</code>操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1010 0011 0110 1111 0101</span><br><span class="line">&amp;   0000 0000 0000 0000 1111</span><br><span class="line">____________________________</span><br><span class="line">    0000 0000 0000 0000 0101</span><br></pre></td></tr></table></figure>
<h2 id="是什么存入了-table"><a href="#是什么存入了-table" class="headerlink" title="是什么存入了 table"></a>是什么存入了 <code>table</code></h2><p><code>HashMap</code>存入<code>table</code>的值并不只有value，而是构造成一个 Node 对象实例存入 table。</p>
<p>Node对象里有：hash, key, value, next(哈希冲突时的链表)</p>
<h2 id="理论最大容量"><a href="#理论最大容量" class="headerlink" title="理论最大容量"></a>理论最大容量</h2><p><code>int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code> </p>
<p>2的30次方</p>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子是用来计算负载容量（所能容纳的最大Node个数）的，当前list长度 length，负载因子 loadFactor</p>
<p>负载容量计算公式为：</p>
<p><code>threshold = length * loadFactor</code></p>
<p>默认负载因子为 0.75。也就是说，当Node个数达到当前list长度的75%时，就要进行扩容，否则会增加哈希碰撞的可能性。<strong>负载因子的作用是在空间和时间效率上取得一个平衡。</strong></p>
<p><code>float DEFAULT_LOAD_FACTOR = 0.75f</code></p>
<h2 id="扩容做了哪些操作"><a href="#扩容做了哪些操作" class="headerlink" title="扩容做了哪些操作"></a>扩容做了哪些操作</h2><ol>
<li><p>创建一个新的Entry空数组，长度是原数组的2倍。<br>当Node个数超过负载容量时，进行扩容。</p>
<p><code>old &lt;&lt; 1</code> 左移一位相当于 old * 2。</p>
</li>
<li><p>重新Hash</p>
<p>遍历原Entry数组，把所有的Entry重新Hash到新数组中。</p>
<p><strong>为什么要重新hash？因为长度扩大以后，hash值也随之改变（数组下标的计算是数组长度对hashcode进行取模）。</strong></p>
<p>这样就可以把原先哈希冲突的链表拉平，使数组变得稀疏。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 保存现有的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 保存现有的数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 保存现有的负载容量</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果现有容量已经超过最大值了，就没办扩容了，只好随你碰撞了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原有容量左移一位，相当于 oldCap * 2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 负载容量也扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负载容量为0，根据数组大小和负载因子计算出来</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 遍历数组中所有元素，重新进行hash</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 删除旧索引位置的值</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 给新的索引位置赋值</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                      * 这个地方可以参考源码系列的第四篇</span></span><br><span class="line"><span class="comment">                      * 《Java源码系列4——HashMap扩容时究竟对链表和红黑树做了什么?》</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 优化链表</span></span><br><span class="line">                    <span class="comment">// 把原有链表拆成两个链表</span></span><br><span class="line">                    <span class="comment">// 链表1存放在低位（原索引位置）</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 链表2存放在高位（原索引 + 旧数组长度）</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                          * 链表1</span></span><br><span class="line"><span class="comment">                          * 这个位运算的原理可以参考源码系列的第四篇</span></span><br><span class="line"><span class="comment">                          * 《Java源码系列4——HashMap扩容时究竟对链表和红黑树做了什么?》</span></span><br><span class="line"><span class="comment">                          */</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 链表2</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表1存放于原索引位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 链表2存放原索引加上旧数组长度的偏移量</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树化改造"><a href="#树化改造" class="headerlink" title="树化改造"></a>树化改造</h2><p>链表长度太长，会被改造成红黑树。</p>
<p>当链表的长度超过<code>MIN_TREEIFY_CAPACITY</code> 最大树化临界值，就会进行树化改造。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要树化？</p>
<p><strong>本质上是个安全问题。</strong>因为链表查询影响性能，如果有人恶意造成哈希碰撞，就会构成哈希碰撞拒绝服务攻击，服务端CPU被大量占用用于链表查询，造成服务变慢或不可用。</p>
<h2 id="源码系列文章"><a href="#源码系列文章" class="headerlink" title="源码系列文章"></a>源码系列文章</h2><p><a href="https://chaohang.top/2020/02/11/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94ArrayList/" target="_blank" rel="noopener">Java源码系列1——ArrayList</a></p>
<p><a href="https://chaohang.top/2020/02/12/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94HashMap/" target="_blank" rel="noopener">Java源码系列2——HashMap</a></p>
<p><a href="https://chaohang.top/2020/02/16/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94LinkedHashMap/" target="_blank" rel="noopener">Java源码系列3——LinkedHashMap</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p>
<p><a href="https://www.zhihu.com/question/20733617/answer/111577937" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？胖君的回答</a></p>
<p><a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">HashMap 源码详细分析(JDK1.8)</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java源码系列1——ArrayList</title>
    <url>/2020/02/11/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94ArrayList/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812105955.jpg" alt=""></p>
<p>本文简单介绍了 <code>ArrayList</code>，并对扩容，添加，删除操作的源代码做分析。能力有限，欢迎指正。</p>
<a id="more"></a>
<h2 id="ArrayList是什么？"><a href="#ArrayList是什么？" class="headerlink" title="ArrayList是什么？"></a>ArrayList是什么？</h2><p><code>ArrayList</code> 就是数组列表，主要用来装载数据。底层实现是数组 <code>Object[] elementData</code>，当我们装载的是基本数据类型 int, long, boolean, shot…的时候我们只能存储他们对应的包装类型。</p>
<p>与它类似的是 <code>LinkedList</code>，和 <code>LinkedList</code> 相比，它的查找和访问元素的速度较快，但新增，删除的速度较慢。</p>
<h2 id="线程安全吗？"><a href="#线程安全吗？" class="headerlink" title="线程安全吗？"></a>线程安全吗？</h2><p>线程不安全。</p>
<p>正常使用场景中，<code>ArrayList</code> 都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用 <code>LinkedList</code>。如果需要线程安全就使用 <code>Vector</code>。</p>
<p><code>Vector</code> 是 <code>ArrayList</code> 的线程安全版本，实现方式就是在所有方法加上<code>synchronized</code>，性能较差。</p>
<h2 id="如何扩容？"><a href="#如何扩容？" class="headerlink" title="如何扩容？"></a>如何扩容？</h2><p>因为数组的大小是固定，当容量超出了现有数组的大小，就需要进行扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 每次扩大原有容量的一半</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩大一半后还是无法满足，则使用minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果超过最大size，则获取最大容量的数组</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么说ArrayList插入效率低？"><a href="#为什么说ArrayList插入效率低？" class="headerlink" title="为什么说ArrayList插入效率低？"></a>为什么说ArrayList插入效率低？</h2><p>原因有两点：</p>
<ol>
<li>新增就要检测容量够不够，如果不够就需要扩容</li>
<li>尾部新增比较快，如果是在数组头部或者中部新增就会慢很多，因为要把后面的元素全部往后移一位</li>
<li>把元素往后移一位使用的是复制 <code>System.arraycopy()</code>，它是<code>native</code>方法（java定义了接口，其他语言进行实现），所以比较快</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加在尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查容量</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 添加在尾部</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按指定位置添加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查容量</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// index后面的元素全部往后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除元素效率如何？"><a href="#删除元素效率如何？" class="headerlink" title="删除元素效率如何？"></a>删除元素效率如何？</h2><p>效率和新增差不多，都是要移动元素，但是不需要检查容量和扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// index后面的元素全部往前移一位</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="适合做队列吗？"><a href="#适合做队列吗？" class="headerlink" title="适合做队列吗？"></a>适合做队列吗？</h2><p>非常不适合。</p>
<p>队列是FIFO，在尾巴进，头部出，出的时候需要移动后面所有数据，效率很低。链表比较适合做队列。</p>
<h2 id="new-ArrayList-lt-gt-18-会不会初始化数组大小？"><a href="#new-ArrayList-lt-gt-18-会不会初始化数组大小？" class="headerlink" title="new ArrayList&lt;&gt;(18) 会不会初始化数组大小？"></a>new ArrayList&lt;&gt;(18) 会不会初始化数组大小？</h2><p>不会初始化数组大小！！！</p>
<p>这是Java Bug。</p>
<p>而且将构造函数与initialCapcity结合使用，然后使用set()方法会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">12</span>);</span><br><span class="line">    System.out.println(a.size());</span><br><span class="line">    a.set(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://cdn.chaohang.top/20200207174641.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>底层实现是数组 <code>Object[] elementData</code></li>
<li>查找和访问元素的速度较快，但新增，删除的速度较慢</li>
<li>线程不安全</li>
<li>每次扩容原有数组大小的一半</li>
</ol>
<h2 id="源码系列文章"><a href="#源码系列文章" class="headerlink" title="源码系列文章"></a>源码系列文章</h2><p><a href="https://chaohang.top/2020/02/11/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94ArrayList/" target="_blank" rel="noopener">Java源码系列1——ArrayList</a></p>
<p><a href="https://chaohang.top/2020/02/12/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94HashMap/" target="_blank" rel="noopener">Java源码系列2——HashMap</a></p>
<p><a href="https://chaohang.top/2020/02/16/Java%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%973%E2%80%94%E2%80%94LinkedHashMap/" target="_blank" rel="noopener">Java源码系列3——LinkedHashMap</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Spring中的IoC和DI</title>
    <url>/2019/12/15/%E7%90%86%E8%A7%A3Spring%E4%B8%AD%E7%9A%84IoC%E5%92%8CDI/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812113400.jpg" alt=""></p>
<h1 id="什么是IoC和DI"><a href="#什么是IoC和DI" class="headerlink" title="什么是IoC和DI"></a>什么是IoC和DI</h1><blockquote>
<p>IoC(Inversion of Control 控制反转)：是一种面向对象编程中的一种设计原则，用来降低计算机代码之间的耦合度。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。</p>
<p>DI(Dependence Injection 依赖注入)：将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>控制反转是一种思想</li>
<li>依赖注入是一种设计模式</li>
<li>IoC框架使用依赖注入作为实现控制反转的方式</li>
</ul>
<h1 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h1><p>在没有IoC之前，我们要在<code>A</code>类中使用<code>B</code>类，就要在<code>A</code>类中<code>new</code>出<code>B</code>类的实例，这样<code>A</code>类和<code>B</code>类之间就出现了耦合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了IoC之后，我们就把实例化这样操作交给框架去帮我们做了。</p>
<h1 id="Spring-中的IoC"><a href="#Spring-中的IoC" class="headerlink" title="Spring 中的IoC"></a>Spring 中的IoC</h1><p>容器是Spring的核心，Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。</p>
<p>Spring容器并不是只有一个，Spring自带多个容器的实现，可以归纳为两种不同的类型：</p>
<ol>
<li>bean工厂(<code>BeanFactory</code>)，最简单的容器，提供基本的DI支持。</li>
<li>应用上下文(<code>ApplicationContext</code>)，继承了<code>BeanFactory</code>，并提供应用框架级别的服务。</li>
</ol>
<p>作为开发人员，我们需要告诉Spring哪些对象要作为bean装配到容器中，bean和bean之间的依赖关系。Spring提供了三种主要的装配机制：</p>
<ul>
<li>隐式的bean发现机制和自动装配</li>
<li>在Java中进行显示配置</li>
<li>在XML中进行显示配置</li>
</ul>
<p>下面我们逐一介绍这三种机制。</p>
<h2 id="自动装配bean"><a href="#自动装配bean" class="headerlink" title="自动装配bean"></a>自动装配bean</h2><h3 id="组件扫描：Spring会自动发现应用上下文中所创建的bean"><a href="#组件扫描：Spring会自动发现应用上下文中所创建的bean" class="headerlink" title="组件扫描：Spring会自动发现应用上下文中所创建的bean"></a>组件扫描：Spring会自动发现应用上下文中所创建的bean</h3><p><code>@Component</code> 注解表明该类会作为组件类，并告知Spring要为这个类创建bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@ComponentScan</code> 注解启用了组件扫描。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动装配：Spring自动满足bean之间的依赖"><a href="#自动装配：Spring自动满足bean之间的依赖" class="headerlink" title="自动装配：Spring自动满足bean之间的依赖"></a>自动装配：Spring自动满足bean之间的依赖</h3><p><code>@Autowired</code> 注解可以作用在构造器、方法、属性上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 属性</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// 从Spring 4.3开始，具有单个构造函数的类可以省略@Autowired注释</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 方法</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在Java中装配bean"><a href="#在Java中装配bean" class="headerlink" title="在Java中装配bean"></a>在Java中装配bean</h2><h3 id="组价配置：声明一个配置类，并在配置类中配置bean"><a href="#组价配置：声明一个配置类，并在配置类中配置bean" class="headerlink" title="组价配置：声明一个配置类，并在配置类中配置bean"></a>组价配置：声明一个配置类，并在配置类中配置bean</h3><p><code>@Configuration</code> 注解表明这个类是配置类，我们可以在配置类下创建bean。</p>
<p><code>@bean</code> 注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring上下文中的bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello bean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 这个方法返回一个对象，Spring会把这个对象注册为bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseBean <span class="title">getBaseBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组件注入：在配置类中把被依赖的组件注入另一个组件中"><a href="#组件注入：在配置类中把被依赖的组件注入另一个组件中" class="headerlink" title="组件注入：在配置类中把被依赖的组件注入另一个组件中"></a>组件注入：在配置类中把被依赖的组件注入另一个组件中</h3><p>两种方式注入bean：</p>
<ol>
<li>我们可以直接调用<code>get</code>方法，获取到对应的组件</li>
<li>在<code>get</code>方法中把被依赖的组件作为参数传入，Spring在调用这个方法时，会自动为你注入。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello bean"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaseBean baseBean;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserBean</span><span class="params">(BaseBean baseBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baseBean = baseBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法返回一个对象，Spring会把这个对象注册为bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseBean <span class="title">getBaseBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下为两种注入bean的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  	<span class="comment">// 方法一：直接调用get方法</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UseBean <span class="title">getUseBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UseBean(getBaseBean());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 方法二：当做参数传入，Spring将自动为你注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UseBean <span class="title">getUseBean</span><span class="params">(BaseBean baseBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UseBean(baseBean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下我们都会使用方法二。</p>
<h2 id="通过XML装配bean"><a href="#通过XML装配bean" class="headerlink" title="通过XML装配bean"></a>通过XML装配bean</h2><p>尽管现在我们已经不怎么再使用XML装配bean，但在Spring刚刚出现的时候，XML是描述配置的主要方式，我们还是有必要了解一下的。</p>
<p>在使用JavaConfig的时候，我们创建了一个配置类来装配bean，而在XML配置中，我们需要创建一个XML文件，并且要以<code>&lt;beans&gt;</code>元素为根。</p>
<p>最为简单的Spring XML配置如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在这里配置你的bean --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><p>以上文的<code>BaseBean</code>为例，我们在XML文件中把它声明为bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baseBean"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.BaseBean"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组件注入"><a href="#组件注入" class="headerlink" title="组件注入"></a>组件注入</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"useBean"</span> <span class="attr">class</span>=<span class="string">"com.example.demo.UseBean"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:_</span>=<span class="string">"baseBean"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>XML的语法我就不再这里详述了，有兴趣的同学可以自行学习。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文我们简单介绍了Spring中的IoC，介绍了Spring中装配bean的三种方式：自动化配置，基于Java的显式配置以及基于XML的显式配置。这些技术都是为了描述Spring应用中的组件以及组件之间的关系。</p>
<p>一般来说我们都会使用自动化配置，尽量避免显式配置带来的维护成本。如果不得不使用显式配置的话，我们优先选择基于Java的配置，它比基于XML的配置更加强大、<strong>类型安全</strong>并且易于重构。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/07af9dbbbc4b" target="_blank" rel="noopener">控制反转（IoC）与依赖注入（DI）</a></p>
<p><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">Spring 实战</a></p>
<p><a href="https://book.douban.com/subject/3897837/" target="_blank" rel="noopener">Spring 揭秘</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解基本原理</title>
    <url>/2019/12/04/Java%E6%B3%A8%E8%A7%A3%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812110050.jpg" alt=""></p>
<h1 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h1><p>「java.lang.annotation.Annotation」接口中有这么一句话，用来描述『注解』。</p>
<blockquote>
<p>The common interface extended by all annotation types<br>所有的注解类型都继承自这个普通的接口（Annotation）</p>
</blockquote>
<a id="more"></a>
<p>这句话有点抽象，但却说出了注解的本质。我们看一个 JDK 内置注解的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是注解 @Override 的定义，其实它本质上就是：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Override</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>没错，注解的本质就是一个继承了 Annotation 接口的接口。有关这一点，你可以去反编译任意一个注解类，你会得到结果的。</p>
<p><strong>一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。</strong></p>
<p>解析一个类或者方法的注解往往有两种形式，一种是编译期直接扫描，一种是运行期反射。</p>
<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>『元注解』是用于修饰注解的注解，通常用在注解的定义上。</p>
<p>JAVA 中有以下几个『元注解』：</p>
<ul>
<li>@Target：注解的作用目标</li>
<li>@Retention：注解的生命周期</li>
<li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li>
<li>@Inherited：是否允许子类继承该注解</li>
</ul>
<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p><code>@Target</code> 注解指明该注解可以作用哪些对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">        * can be applied to.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">        * can be applied to</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解接收一个ElementType数组，ElementType是一个枚举，成员如下：</p>
<ul>
<li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li>
<li>ElementType.FIELD：允许作用在属性字段上</li>
<li>ElementType.METHOD：允许作用在方法上</li>
<li>ElementType.PARAMETER：允许作用在方法参数上</li>
<li>ElementType.CONSTRUCTOR：允许作用在构造器上</li>
<li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li>
<li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li>
<li>ElementType.PACKAGE：允许作用在包上</li>
<li>ElementType.TYPE_PARAMETER：允许作用在类型参数上</li>
<li>ElementType.TYPE_USE：允许作用在类型上</li>
</ul>
<h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>@Retention 用于指明当前注解的生命周期<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns the retention policy.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注解接收一个RetentionPolicy数据，RetentionPolicy是个枚举，成员如下：</p>
<ul>
<li>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件</li>
<li>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件</li>
<li>RetentionPolicy.RUNTIME：永久保存，可以反射获取</li>
</ul>
<h1 id="JAVA-的内置三大注解"><a href="#JAVA-的内置三大注解" class="headerlink" title="JAVA 的内置三大注解"></a>JAVA 的内置三大注解</h1><ul>
<li>@Override</li>
<li>@Deprecated  标识类或方法不再推荐使用</li>
<li>@SuppressWarnings 主要用来压制 java 的警告</li>
</ul>
<h1 id="实现一个自己的注解"><a href="#实现一个自己的注解" class="headerlink" title="实现一个自己的注解"></a>实现一个自己的注解</h1><p>定义一个注解：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HelloAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "Hello annotation!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用这个注解：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAnnotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HelloAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HelloAnnotation</span>(<span class="string">"Hello world!"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注解最重要的部分在于对注解的处理。注解处理器就是通过反射机制获取被检查方法上的注解信息，然后根据注解元素的值进行特定的处理。如果没有注解处理器，注解就是个注释，或者连注释都不如。</p>
<p>处理这个注解：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAnnotation(UseAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAnnotation</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            HelloAnnotation ha = m.getAnnotation(HelloAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (ha != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found My Annotation: "</span> + ha.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Found My Annotation: Hello annotation!</span><br><span class="line">Found My Annotation: Hello world!</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/yangming1996/p/9295168.html" target="_blank" rel="noopener">JAVA 注解的基本原理</a></p>
<p><a href="https://www.jianshu.com/p/f5b564693c43" target="_blank" rel="noopener">Java注解基本原理</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
<p>欢迎关注我的微信公众号 【超超不会飞】，获取第一时间的更新。</p>
<p><img data-src="http://cdn.chaohang.top/20200605101838.png" alt=""></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>堆（优先队列）</title>
    <url>/2019/08/25/%E5%A0%86/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>堆(heap)也被称为优先队列(priority queue)。是一种特殊的树状数据结构。</p>
<a id="more"></a>
<p>普通队列是先进先出(first in first out)，而优先队列出栈的顺序是按照元素的优先权大小。</p>
<p>堆可以分为”大顶堆“也称”最大堆“（最大值优先出列），”小顶堆“也称”最小堆“（最小值优先出列）。</p>
<p><img data-src="http://cdn.chaohang.top/20200110111442.png" alt=""></p>
<p>堆的常用方法：</p>
<ul>
<li>构建优先队列</li>
<li>快速找出最大值(最小值)</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>堆是用数组实现的完全二叉树。目前有多种算法可以实现堆，速度最快的是斐波那契堆。</p>
<p><img data-src="http://cdn.chaohang.top/20200110111504.png" alt=""></p>
<p>具体的实现可以参考一下这两篇文章</p>
<p><a href="https://medium.com/basecs/learning-to-love-heaps-cef2b273a238" target="_blank" rel="noopener">Learning to Love Heaps</a><br><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">Heap</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="[https://leetcode.com/problems/kth-largest-element-in-a-stream/](https://leetcode.com/problems/kth-largest-element-in-a-stream/">LeetCode第703题Kth Largest Element in a Stream</a><br>)就是一个使用堆的场景，如果我们使用简单的数组排序的方法很有可能超时，使用堆是该题的最优解之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; q;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.size() &lt; k) &#123;</span><br><span class="line">            q.offer(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q.peek() &lt; val) &#123;</span><br><span class="line">            q.poll();</span><br><span class="line">            q.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">Heap wiki</a>)</p>
<p><a href="https://medium.com/basecs/learning-to-love-heaps-cef2b273a238" target="_blank" rel="noopener">Learning to Love Heaps</a></p>
<p><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap" target="_blank" rel="noopener">Heap</a></p>
<p><a href="https://www.geeksforgeeks.org/heap-data-structure/" target="_blank" rel="noopener">Heap Data Structure</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode20——有效的括号</title>
    <url>/2019/08/20/LeetCode20%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<a id="more"></a>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p>
<p>示例 2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p>
<p>示例 3:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p>
<p>示例 4:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p>
<p>示例 5:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题需要利用 <code>栈</code> 数据结构先进后出的特点。如果遇到左括号则<code>push</code>入栈中，如果遇到右括号，则需要从栈中<code>pop</code>出一个与之匹配的左括号，否则该字符串不合法。</p>
<p>全部判断完后，该栈需要为空，不为空则表示该字符串不合法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">const</span> paren_map = &#123;<span class="string">')'</span>: <span class="string">'('</span>, <span class="string">']'</span>: <span class="string">'['</span>, <span class="string">'&#125;'</span>: <span class="string">'&#123;'</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(i <span class="keyword">in</span> paren_map)) </span><br><span class="line">            stack.push(i)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.length === <span class="number">0</span> || stack.pop() !== paren_map[i]) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<h2 id="开心消消乐解法"><a href="#开心消消乐解法" class="headerlink" title="开心消消乐解法"></a>开心消消乐解法</h2><p>在LeetCode上还看到一种有趣的解法，把两两匹配的括号全部消掉，直到没有两两匹配的括号为止，如果字符串为空则为<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        length = s.length</span><br><span class="line">        s = s.replace(<span class="string">"()"</span>, <span class="string">""</span>).replace(<span class="string">"[]"</span>, <span class="string">""</span>).replace(<span class="string">"&#123;&#125;"</span>, <span class="string">""</span>)</span><br><span class="line">    &#125; <span class="keyword">while</span>(length !== s.length)</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCod</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode141——环形链表</title>
    <url>/2019/08/18/LeetCode141%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，如何判断链表中是否有环。</p>
<a id="more"></a>
<p><img data-src="http://cdn.chaohang.top/20200110105836.png" alt=""></p>
<h2 id="方法一：硬破解"><a href="#方法一：硬破解" class="headerlink" title="方法一：硬破解"></a>方法一：硬破解</h2><p>循环一定次数，或者循环一定的时间，还没有出来的就是进入到环里了，至于循环几次或者循环多久，有空的朋友可以慢慢调这个参数。🙂🙂🙂</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = head</span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(now) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">10000</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        now = now.next</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h2><p>我们可以用一个 <code>set</code> 存下之前访问过的节点，如果再次访问了这个节点，则有环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">    let now = head</span><br><span class="line">    while(now) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">set</span>.has(now)) return true</span><br><span class="line">        <span class="keyword">set</span>.add(now)</span><br><span class="line">        now = now.next</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复制读：O(n)</p>
<h2 id="方法三：龟兔赛跑"><a href="#方法三：龟兔赛跑" class="headerlink" title="方法三：龟兔赛跑"></a>方法三：龟兔赛跑</h2><p>有两个指针，一个快指针，一个慢指针，快指针一次走两步，慢指针一次走一步。如果链表有环，则两个指针最终将会相遇。如果没有环，则永远不会相遇。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = slow = head</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; slow &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">        <span class="keyword">if</span> (fast === slow) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCod</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode206——反转链表</title>
    <url>/2019/08/13/LeetCode206%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>反转一个单链表。</p>
<p>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>反转链表的关键在于将当前节点的 <code>next</code> 指向前一节点。</p>
<h2 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h2><p>需要两个变量，分别用来存储当前节点和上一节点，并把当前节点的 <code>next</code> 指向上一节点，然后前进一位，直到结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cur = head</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">var</span> next = cur.next</span><br><span class="line">        cur.next = prev</span><br><span class="line">        prev = cur</span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(1)</p>
<h2 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h2><p>递归理解起来比较绕。假设有 <code>1-&gt;2-&gt;3-&gt;null</code> 这样一个链表，当执行到3时开始反转，此时 <code>list</code> 为 <code>3-&gt;null</code>，<code>head</code> 为 2，此时2的状态为 <code>2-&gt;3-&gt;null</code>，要变为 <code>3-&gt;2-&gt;null</code> 则需要让 <code>head.next.next = head</code>，并且 <code>head.next = null</code>，画了个图：</p>
<p><img data-src="http://cdn.chaohang.top/20200110105726.png" alt="">)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> list = reverseList(head.next)</span><br><span class="line">  head.next.next = head</span><br><span class="line">  head.next = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)<br>空间复杂度O(n)，因为使用了递归</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCod</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间算法40讲笔记之一——如何学习</title>
    <url>/2019/08/10/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E7%AE%97%E6%B3%9540%E8%AE%B2%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="如何有效学习数据结构"><a href="#如何有效学习数据结构" class="headerlink" title="如何有效学习数据结构"></a>如何有效学习数据结构</h2><ol>
<li>Chunk it up (切碎知识点)<br> 比如要学习算法与数据结构，我们可以把想要学习的数据结构和算法罗列出来，在整理出他们之间的关系，然后各个击破。</li>
</ol>
<a id="more"></a>
<p><img data-src="http://cdn.chaohang.top/20200212120149.png" alt=""></p>
<p><img data-src="http://cdn.chaohang.top/20200212120205.png" alt=""></p>
<p><img data-src="http://cdn.chaohang.top/20200212120214.png" alt=""></p>
<ol start="2">
<li>Deliberate practicing (刻意练习)<ul>
<li>练习缺陷、弱点的地方</li>
<li>练习时会不舒服、不爽、枯燥</li>
<li>会有一个下降后上升的曲线，重复这个曲线就能够提高</li>
</ul>
</li>
<li>Feedback (反馈)<ul>
<li>及时反馈</li>
<li>主动型反馈<ul>
<li>看别人的代码（GitHub，LeetCode）</li>
</ul>
</li>
<li>被动型反馈<ul>
<li>code review</li>
<li>写博客，输出</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="如何刷题"><a href="#如何刷题" class="headerlink" title="如何刷题"></a>如何刷题</h2><p>切题四件套</p>
<ul>
<li>Clarification (审题)</li>
<li>Possible solution (可能的解决办法)<ul>
<li>compare(time/spac) (比较多种解决方法之间的差别)</li>
<li>optimal (找出最优解)</li>
</ul>
</li>
<li>Coding (多写)</li>
<li>Test cases</li>
</ul>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><img data-src="http://cdn.chaohang.top/20200212120225.png" alt=""></p>
<p><img data-src="http://cdn.chaohang.top/20200212120236.png" alt=""></p>
]]></content>
      <tags>
        <tag>极客时间</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之TypeScript中的单例模式</title>
    <url>/2019/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BTypeScript%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式指的是一个类只能有一个实例存在。</p>
<p>在实际应用中有些场景我们只需要唯一实例的存在，如果出现多个实例就会出现问题，这个时候我们就需要用到单例模式。比如线程池，缓存，硬件设备等。</p>
<a id="more"></a>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>每个类中都有一个构造函数 <code>constructor</code>，当我们 <code>new</code> 这个类时，实际上就是在调用这个构造函数。比如我们定义了一个 <code>Car</code> 类，实例化了一只叫“茶”的小猫咪和一只叫“菊”的小猫咪。此时我们声明了两个 <code>Car</code> 的实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  name: string</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cha = <span class="keyword">new</span> Car(<span class="string">'茶'</span>)</span><br><span class="line"><span class="keyword">const</span> ju = <span class="keyword">new</span> Car(<span class="string">'菊'</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们把<strong>构造函数变成私有函数</strong>，外部就无法将这个类实例化。</p>
<p><img data-src="http://cdn.chaohang.top/20200110111200.png" alt=""></p>
<p>所以，只要我们把一个类的构造函数私有化，并在类内部实例化出唯一的一个实例，就可以实现单例模式了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  private <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明一个私有的静态属性作为唯一的实例</span></span><br><span class="line">  private <span class="keyword">static</span> INSTANCE: Singleton = <span class="keyword">new</span> Singleton()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露一个公开的方法用于获取实例</span></span><br><span class="line">  public getInstance() &#123;</span><br><span class="line">    <span class="keyword">return</span> Singleton.INSTANCE</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="饿汉模式和懒汉模式"><a href="#饿汉模式和懒汉模式" class="headerlink" title="饿汉模式和懒汉模式"></a>饿汉模式和懒汉模式</h2><p>单例模式又分为饿汉模式和懒汉模式</p>
<ul>
<li>饿汉模式：指全局的单例实例在类装载时构建</li>
<li>懒汉模式：指全局的单例实例在第一次被使用时构建</li>
</ul>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  private <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明一个私有的静态属性作为唯一的实例</span></span><br><span class="line">  private <span class="keyword">static</span> INSTANCE: Singleton = <span class="keyword">new</span> Singleton()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露一个公开的方法用于获取实例</span></span><br><span class="line">  public getInstance() &#123;</span><br><span class="line">    <span class="keyword">return</span> Singleton.INSTANCE</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饿汉模式-1"><a href="#饿汉模式-1" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  private <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明一个私有的静态属性作为唯一的实例</span></span><br><span class="line">  private <span class="keyword">static</span> INSTANCE?: Singleton = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露一个公开的方法用于获取实例</span></span><br><span class="line">  public getInstance() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Singleton.INSTANCE) &#123;</span><br><span class="line">      Singleton.INSTANCE = <span class="keyword">new</span> Singleton()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Singleton.INSTANCE</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深入JavaScript之模拟apply,call,bind</title>
    <url>/2019/07/23/%E6%B7%B1%E5%85%A5JavaScript%E4%B9%8B%E6%A8%A1%E6%8B%9Fapply-call-bind/</url>
    <content><![CDATA[<p><code>apply</code> <code>call</code> <code>bind</code> 这三个函数可以改变 <code>this</code> 的绑定，语法上有略微差别，可以看我很早之前的一篇文章做过简单的介绍 <a href="https://www.jianshu.com/p/cca23ce280be" target="_blank" rel="noopener">浅谈JavaScript中的apply、call、bind</a>。</p>
<a id="more"></a>
<h2 id="this-优先级"><a href="#this-优先级" class="headerlink" title="this 优先级"></a>this 优先级</h2><ol>
<li><code>new</code> 关键字。函数被 <code>new</code> 调用，<code>this</code> 指向由 <code>new</code> 新构建出来的这个对象</li>
<li>函数通过 <code>apply call bind</code> 调用，<code>this</code> 指向绑定的对象</li>
<li>函数被调用时，<code>this</code> 指向调用的对象</li>
<li>默认。非严格模式情况下，this指向window, 严格模式下，this指向undefined。</li>
</ol>
<p>总结一下优先级<br><code>new</code> 关键字 &gt; <code>apply call bind</code> &gt; 函数调用 &gt; 默认</p>
<!-- more -->
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们既然要重写 <code>apply</code>，那前两个优先级是用不了的。我们使用第三个优先级——函数调用——改变 <code>this</code> 的指向。</p>
<p>先看下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  args = args || []</span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()  <span class="comment">// 保证key的唯一性，避免覆盖原有的属性方法</span></span><br><span class="line">  context[key] = <span class="keyword">this</span>   <span class="comment">// 此时的this指向myApply的调用者</span></span><br><span class="line">  <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">  <span class="keyword">delete</span> context[key]   <span class="comment">// 删掉新建的key</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码忽略一些边界情况，实现了简易版的 <code>apply</code>。<br>看下使用的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'A'</span>,</span><br><span class="line">  getName(prefix, suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;prefix&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;suffix&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = person.getName.myApply(&#123;<span class="attr">name</span>: <span class="string">'apply'</span>&#125;, [<span class="string">'one'</span>, <span class="string">'two'</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// one apply two</span></span><br></pre></td></tr></table></figure>
<p>首先我们创建了一个 <code>Symbol</code> 对象作为 <code>context</code> 的 <code>key</code>，并把 <code>this</code> 赋值给他。此时的 <code>this</code> 值为 <code>getName</code>，因为是 <code>getName</code> 调用了 <code>myApply</code>，所以 <code>this</code> 指向调用者。<br>当我们以 <code>context[key](...args)</code> 这种方式调用 <code>getName</code> 时，<code>this</code> 指向了 <code>context</code>，因为是 <code>context</code> 调用了 <code>getName</code> 方法。借此完成了 <code>this</code> 值得转换。</p>
<p><code>call</code> 和 <code>bind</code> 同理</p>
<p><code>call</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()</span><br><span class="line">  context[key] = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">  <span class="keyword">delete</span> context[key]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bind</code> 的实现可以使用我们写的 <code>call</code> 函数。需要注意的是 <code>bind</code> 可以传参，新生成的函数也可以传参。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newFn</span>(<span class="params">...newFnArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.myCall(context, ...args, ...newFnArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>查询各个科目成绩前三的记录</title>
    <url>/2019/06/19/%E6%9F%A5%E8%AF%A2%E5%90%84%E4%B8%AA%E7%A7%91%E7%9B%AE%E6%88%90%E7%BB%A9%E5%89%8D%E4%B8%89%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>id</th>
<th>student_id</th>
<th>name</th>
<th>course_id</th>
<th>course_name</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2005001</td>
<td>张三</td>
<td>1</td>
<td>数学</td>
<td>69</td>
</tr>
<tr>
<td>2</td>
<td>2005002</td>
<td>李四</td>
<td>1</td>
<td>数学</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>2005005</td>
<td>王五</td>
<td>1</td>
<td>数学</td>
<td>23</td>
</tr>
<tr>
<td>3</td>
<td>2005001</td>
<td>张三</td>
<td>2</td>
<td>语文</td>
<td>69</td>
</tr>
<tr>
<td>3</td>
<td>2005002</td>
<td>李四</td>
<td>2</td>
<td>语文</td>
<td>73</td>
</tr>
<tr>
<td>3</td>
<td>2005005</td>
<td>王五</td>
<td>2</td>
<td>语文</td>
<td>88</td>
</tr>
<tr>
<td>1</td>
<td>2005006</td>
<td>赵六</td>
<td>2</td>
<td>语文</td>
<td>69</td>
</tr>
<tr>
<td>2</td>
<td>2005006</td>
<td>赵六</td>
<td>1</td>
<td>数学</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>2005007</td>
<td>郑七</td>
<td>2</td>
<td>语文</td>
<td>100</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span>          <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`student_id`</span>  <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span>        <span class="built_in">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_id`</span>   <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span>       <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span> (<span class="string">`student_id`</span>, <span class="string">`name`</span>, <span class="string">`course_id`</span>, <span class="string">`course_name`</span>, <span class="string">`score`</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2005001</span>, <span class="string">'张三'</span>, <span class="number">1</span>, <span class="string">'数学'</span>, <span class="number">69</span>),</span><br><span class="line">       (<span class="number">2005002</span>, <span class="string">'李四'</span>, <span class="number">1</span>, <span class="string">'数学'</span>, <span class="number">80</span>),</span><br><span class="line">       (<span class="number">2005005</span>, <span class="string">'王五'</span>, <span class="number">1</span>, <span class="string">'数学'</span>, <span class="number">23</span>),</span><br><span class="line">       (<span class="number">2005001</span>, <span class="string">'张三'</span>, <span class="number">2</span>, <span class="string">'语文'</span>, <span class="number">69</span>),</span><br><span class="line">       (<span class="number">2005002</span>, <span class="string">'李四'</span>, <span class="number">2</span>, <span class="string">'语文'</span>, <span class="number">73</span>),</span><br><span class="line">       (<span class="number">2005005</span>, <span class="string">'王五'</span>, <span class="number">2</span>, <span class="string">'语文'</span>, <span class="number">88</span>),</span><br><span class="line">       (<span class="number">2005006</span>, <span class="string">'赵六'</span>, <span class="number">2</span>, <span class="string">'语文'</span>, <span class="number">69</span>),</span><br><span class="line">       (<span class="number">2005006</span>, <span class="string">'赵六'</span>, <span class="number">1</span>, <span class="string">'数学'</span>, <span class="number">89</span>),</span><br><span class="line">       (<span class="number">2005007</span>, <span class="string">'郑七'</span>, <span class="number">2</span>, <span class="string">'语文'</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-用一条-SQL-语句查询出每门课都大于-80-分的学生姓名"><a href="#1-用一条-SQL-语句查询出每门课都大于-80-分的学生姓名" class="headerlink" title="1. 用一条 SQL 语句查询出每门课都大于 80 分的学生姓名"></a>1. 用一条 SQL 语句查询出每门课都大于 80 分的学生姓名</h3><p>理解：分数最小的那门课大于80，自然每门课都大于80了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span> <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`name`</span> <span class="keyword">HAVING</span> <span class="keyword">min</span>(<span class="string">`score`</span>) &gt;= <span class="number">80</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-查询各个科目成绩前三的记录"><a href="#2-查询各个科目成绩前三的记录" class="headerlink" title="2. 查询各个科目成绩前三的记录"></a>2. 查询各个科目成绩前三的记录</h3><p>思路：查出该科成绩超过他的人数小于3的学生，再进行排列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`student_id`</span>, <span class="string">`name`</span>, <span class="string">`course_id`</span>, <span class="string">`course_name`</span>, <span class="string">`score`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`test`</span> <span class="string">`t1`</span></span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> <span class="string">`test`</span> <span class="string">`t2`</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="string">`t1`</span>.<span class="string">`course_id`</span> = <span class="string">`t2`</span>.<span class="string">`course_id`</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="string">`t1`</span>.<span class="string">`score`</span> &lt; <span class="string">`t2`</span>.<span class="string">`score`</span></span><br><span class="line">) &lt; <span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`course_id`</span>, <span class="string">`score`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://cdn.chaohang.top/20200110110851.png" alt=""></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL重复数据的处理</title>
    <url>/2019/06/19/mysql%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>假设有一张表如下，含有部分重复数据，这些重复数据除了 <code>id</code> 不同，其他数据都相同。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>id</th>
<th>student_id</th>
<th>name</th>
<th>course_id</th>
<th>course_name</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2005001</td>
<td>张三</td>
<td>1</td>
<td>数学</td>
<td>69</td>
</tr>
<tr>
<td>2</td>
<td>2005002</td>
<td>李四</td>
<td>1</td>
<td>数学</td>
<td>89</td>
</tr>
<tr>
<td>3</td>
<td>2005001</td>
<td>张三</td>
<td>1</td>
<td>数学</td>
<td>69</td>
</tr>
</tbody>
</table>
<!-- more -->
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span>          <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`student_id`</span>  <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span>        <span class="built_in">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_id`</span>   <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span>       <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`test`</span> (<span class="string">`student_id`</span>, <span class="string">`name`</span>, <span class="string">`course_id`</span>, <span class="string">`course_name`</span>, <span class="string">`score`</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2005001</span>, <span class="string">'张三'</span>, <span class="number">1</span>, <span class="string">'数学'</span>, <span class="number">69</span>),</span><br><span class="line">       (<span class="number">2005002</span>, <span class="string">'李四'</span>, <span class="number">1</span>, <span class="string">'数学'</span>, <span class="number">89</span>),</span><br><span class="line">       (<span class="number">2005001</span>, <span class="string">'张三'</span>, <span class="number">1</span>, <span class="string">'数学'</span>, <span class="number">69</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-过滤重复数据"><a href="#1-过滤重复数据" class="headerlink" title="1. 过滤重复数据"></a>1. 过滤重复数据</h3><p>使用 <code>group by</code> 进行查找就可以过滤重复数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`student_id`</span>, <span class="string">`name`</span>, <span class="string">`course_id`</span>, <span class="string">`course_name`</span>, <span class="string">`score`</span> <span class="keyword">FROM</span> <span class="string">`test`</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`student_id`</span>, <span class="string">`name`</span>, <span class="string">`course_id`</span>, <span class="string">`course_name`</span>, <span class="string">`score`</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-统计重复数据"><a href="#2-统计重复数据" class="headerlink" title="2. 统计重复数据"></a>2. 统计重复数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> <span class="string">`repetitions`</span>, <span class="string">`name`</span> <span class="keyword">FROM</span> <span class="string">`test`</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`student_id`</span>, <span class="string">`name`</span>, <span class="string">`course_id`</span>, <span class="string">`course_name`</span>, <span class="string">`score`</span></span><br><span class="line">  <span class="keyword">HAVING</span> <span class="string">`repetitions`</span> &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="3-删除重复数据"><a href="#3-删除重复数据" class="headerlink" title="3. 删除重复数据"></a>3. 删除重复数据</h3><p>思路：分组后，选出 <code>id</code> 最小的一条，不被选中的 <code>id</code> 全部删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`test`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`id`</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="string">`min_id`</span></span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">min</span>(<span class="string">`id`</span>) <span class="keyword">AS</span> <span class="string">`min_id`</span></span><br><span class="line">        <span class="keyword">FROM</span> <span class="string">`test`</span></span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`student_id`</span>, <span class="string">`name`</span>, <span class="string">`course_id`</span>, <span class="string">`course_name`</span>, <span class="string">`score`</span>) <span class="keyword">AS</span> <span class="string">`a`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode176——第二高的薪水</title>
    <url>/2019/06/19/LeetCode176%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（<code>Salary</code>） 。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>
<p>例如上述 <code>Employee</code> 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>排序，取出排名第二的值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Salary <span class="keyword">from</span> Employee</span><br><span class="line">  <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line">  <span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>group by 过滤掉相同薪水</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Salary <span class="keyword">from</span> Employee</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> Salary</span><br><span class="line">  <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line">  <span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>当不存在第二高的薪水时，会返回空而不是 <code>null</code>，做个是否为 <code>null</code> 的判断</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="keyword">ifnull</span>(</span><br><span class="line">    (<span class="keyword">select</span> Salary <span class="keyword">from</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> Salary <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">  ) <span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure>
<p>可以简写为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  (<span class="keyword">select</span> Salary <span class="keyword">from</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> Salary <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 Node.js 的 GC 机制</title>
    <url>/2019/06/02/%E7%90%86%E8%A7%A3%20Node.js%20%E7%9A%84%20GC%20%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>《深入浅出Node.js》第五章《内存控制》阅读笔记</p>
</blockquote>
<p>随着 Node 的发展，JavaScript 的应用场景早已不再局限在浏览器中。本文不讨论网页应用、命令行工具等短时间执行，且只影响终端用户的场景。由于运行时间短，随着进程的退出，内存会释放，几乎没有内存管理的必要。但随着 Node 在服务端的广泛应用，JavaScript 的内存管理需要引起我们的重视。</p>
<h2 id="V8-的内存限制"><a href="#V8-的内存限制" class="headerlink" title="V8 的内存限制"></a>V8 的内存限制</h2><p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB）。在这样的限制下，将会导致 Node 无法直接操作大内存对象。</p>
<p>造成这个问题的主要原因在于 Node 的 JavaScript 执行引擎 V8。</p>
<p>在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的。Node 提供了 V8 中内存的使用量查看方法 <code>process.memoryUsage()</code>。</p>
<a id="more"></a>
<p><img data-src="http://cdn.chaohang.top/20200110110020.png" alt=""></p>
<ul>
<li><code>heapTotal</code> 已申请到的堆内存</li>
<li><code>heapUsed</code> 当前使用的堆内存</li>
</ul>
<p>为什么 V8 要限制堆的大小：</p>
<ol>
<li>V8 为浏览器而设计，不太可能遇到用大量内存的场景</li>
<li>V8 的垃圾回收机制的限制。（按官方的说法，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收需要1s以上）</li>
</ol>
<p>V8提供了选项让我们可以控制使用内存的大小</p>
<ul>
<li><code>node --max-old-space-size=1700 test.js</code>  设置老生代内存空间最大值，单位为MB</li>
<li><code>node --max-new-space-size=1024 test.js</code> 设置新生代内存空间最大值，单位为KB</li>
</ul>
<p>比较遗憾的是，这两个最大值需要在启动时执行。这意味着 V8 使用的内存没办法根据使用的情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。</p>
<h2 id="V8-的垃圾回收机制"><a href="#V8-的垃圾回收机制" class="headerlink" title="V8 的垃圾回收机制"></a>V8 的垃圾回收机制</h2><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制。在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p>
<p><img data-src="http://cdn.chaohang.top/20200110110046.png" alt=""></p>
<p>V8 堆的整体大小就是新生代的内存空间加上老生代的内存空间</p>
<h3 id="Scavenge-算法"><a href="#Scavenge-算法" class="headerlink" title="Scavenge 算法"></a>Scavenge 算法</h3><p>在分代的基础上，新生代中的对象主要通过 <code>Scavenge</code> 算法进行垃圾回收。在 Scavenge 的具体实现中，主要采用了 <code>Cheney</code> 算法。</p>
<blockquote>
<p>Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为 <code>semispace</code>。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置中。处于使用中的 semispace 空间成为 <code>From</code> 空间，处于闲置状态的空间成为 <code>To</code> 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将被释放。完成复制后， From 空间和 To 空间的角色发生对换。</p>
</blockquote>
<p>Scavenge 的缺点是只能使用堆内存的一半，但 Scavenge 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上表现优异。Scavenge 是典型的牺牲空间换取时间的算法，无法大规模地应用到所有的垃圾回收中，但非常适合应用在新生代中。</p>
<p><img data-src="http://cdn.chaohang.top/20200110110122.png" alt=""></p>
<h3 id="晋升"><a href="#晋升" class="headerlink" title="晋升"></a>晋升</h3><p>对象从新生代中移动到老生代中的过程称为晋升。</p>
<p>From 空间中的存活对象在复制到 To 空间之前需要进行检查，在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象的晋升。</p>
<p>晋升条件主要有两个：</p>
<ol>
<li>对象是否经历过一次 Scavenge 回收</li>
<li>To 空间已经使用超过 25%</li>
</ol>
<p>设置 25% 这个限制值得原因是当这次 Scavenge 回收完成后，这个 To 空间将变成 From 空间，接下来的内存分配将在这个空间中进行，如果占比过高，会影响后续的内存分配。</p>
<h3 id="Mark-Sweep-amp-Mark-Compact"><a href="#Mark-Sweep-amp-Mark-Compact" class="headerlink" title="Mark-Sweep &amp; Mark-Compact"></a>Mark-Sweep &amp; Mark-Compact</h3><p>V8 在老生代中主要采用了 Mark-Sweep 和 Mark-Compact 相结合的方式进行垃圾回收。</p>
<p>Mark-Sweep 是标记清除的意思，它分为两个阶段，标记和清除。Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除未被标记的对象。</p>
<p><img data-src="http://cdn.chaohang.top/20200110110150.png" alt=""></p>
<p>Mark-Sweep 最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p>
<p>为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact 被提出来。Mark-Compact是标记整理的意思，是在 Mark-Sweep 的基础上演进而来的。它们的差别在于对象在标记为死亡后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>
<p><img data-src="http://cdn.chaohang.top/20200110110213.png" alt=""></p>
<p>下表为3种主要垃圾回收算法的简单比较</p>
<p><img data-src="http://cdn.chaohang.top/20200110110311.png" alt=""></p>
<p>从表中可以看出，在 Mark-Sweep 和 Mark-Compact 之间，由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep，在空间不足以从新生代中晋升过来的对象进行分配时才使用 Mark-Compact 。</p>
<h3 id="Incremental-Marking"><a href="#Incremental-Marking" class="headerlink" title="Incremental Marking"></a>Incremental Marking</h3><p>为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种算法都需要将应用逻辑暂停下来，这种行为称为“全停顿” (stop-the-world)。</p>
<p>由于新生代配置的空间较小，存活对象较少，全停顿对新生代影响不大。但老生代通常配置的空间较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清除、整理等动作造成的停顿就会比较可怕。</p>
<p>为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改成增量标记(Incremental Marking)，也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收和应用逻辑交替执行直到标记阶段完成。</p>
<p><img data-src="http://cdn.chaohang.top/20200110110335.png" alt=""></p>
<p>V8 在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的 1/6 左右。</p>
<h2 id="查看GC日志"><a href="#查看GC日志" class="headerlink" title="查看GC日志"></a>查看GC日志</h2><p>查看垃圾回收日志的方式主要是在启动时添加 <code>--trace_gc</code> 参数。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>Node 的 JavaScript 执行引擎为 V8，内存使用和控制也受限于 V8。</li>
<li>V8 把内存分为新生代和老生代，分别存放存活时间较短和存活时间较长或常驻内存的对象。</li>
<li>在新生代中使用  Scavenge 算法进行垃圾回收，优点是速度快无内存碎片，缺点是占用双倍内存空间。</li>
<li>在老生代中将 Mark-Sweep 和 Mark-Compact 两种算法结合使用，主要使用 Mark-Sweep，优点的是无需移动对象，缺点是产生内存碎片。Mark-Compact 是对 Mark-Sweep 的补充，在空间不足以对新晋升的对象进行分配时整理内存，清除内存碎片，由于要移动对象，速度较慢。</li>
<li>V8 使用 Incremental Marking 来减少全停顿带来的影响。</li>
</ol>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode70——爬楼梯</title>
    <url>/2019/05/26/LeetCode70%E2%80%94%E2%80%94%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<a id="more"></a>
<p>示例 1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每次可以爬 1 或 2 个台阶。当我们爬 4 个台阶时，就是爬 3 个台阶的方法数，加上爬 2 个台阶的方法数，等于 F(3) + F(2) = 3 + 2 = 5。所以当我们爬 N 个台阶，就有 F(N - 1) + F(N - 2) 种方法。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：暴力破解"><a href="#方案一：暴力破解" class="headerlink" title="方案一：暴力破解"></a>方案一：暴力破解</h3><p>我们可以用递归的方法得到所有小于N的方法数，并把它们相加得出结果。递归结束的标志为 N=1 或 N =2。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O($2^n$)。这种暴力解题的方法会超出时间限制，显然不是我们想要的。</p>
<h3 id="方案二：优化暴力破解"><a href="#方案二：优化暴力破解" class="headerlink" title="方案二：优化暴力破解"></a>方案二：优化暴力破解</h3><p>从上一种方法我们可以发现，每一步的结果都做了上一步的重复计算。比如F(6) + F(5) 后会计算 F(5) + F(4)，F(5) 我们已经计算过了，就不要重复计算了。所以我们可以用一个数组来储存计算结果，方便重复利用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">climb</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (arr[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> arr[n]</span><br><span class="line">        </span><br><span class="line">        arr[n] = climb(n - <span class="number">1</span>) + climb(n - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[n]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climb(n)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(n)，优化之后提高了速度，已经不会超出时间限制了。</p>
<h3 id="方案三：问题分解"><a href="#方案三：问题分解" class="headerlink" title="方案三：问题分解"></a>方案三：问题分解</h3><p>和递归的思路一样，把一个大问题分解成多个小问题，只是这次我们使用循环的方式，减少内存的开销。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i&lt;= n; i++) &#123;</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(n)，优化了内存的消耗，速度没有提升。</p>
<h3 id="方案四：斐波那契数"><a href="#方案四：斐波那契数" class="headerlink" title="方案四：斐波那契数"></a>方案四：斐波那契数</h3><p>从上一个方案我们可以看出这是一个斐波那契数列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> first = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> second = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i&lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> third = first + second</span><br><span class="line">        first = second</span><br><span class="line">        second = third</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(n)</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 trash 避免 rm -rf 悲剧</title>
    <url>/2019/04/24/%E4%BD%BF%E7%94%A8-trash-%E9%81%BF%E5%85%8D-rm-rf-%E6%82%B2%E5%89%A7/</url>
    <content><![CDATA[<p>昨晚做了一个令人痛心疾首的操作，<code>rm -rf something</code>，把我个人电脑里的重要文件夹给删掉了，懵逼了半天才缓过来。还好是个人文件，不对公司造成影响。这件事也让我意识到 <code>rm -rf</code> 确实是个高风险操作，文件备份也是重中之重。</p>
<a id="more"></a>
<p>为了规避这个风险操作，我决定用 <code>trash</code> 替代 <code>rm</code>，这样文件就不会直接被删除，而是进入废纸篓。</p>
<h2 id="安装-trash"><a href="#安装-trash" class="headerlink" title="安装 trash"></a>安装 trash</h2><p><a href="https://formulae.brew.sh/formula/trash" target="_blank" rel="noopener">trash–CLI tool that moves files or folder to the trash</a></p>
<p>使用 homebrew 安装 trash<br><code>brew install trash</code></p>
<!-- more -->
<h2 id="配置命令行"><a href="#配置命令行" class="headerlink" title="配置命令行"></a>配置命令行</h2><p>安装完之后在 <code>.zshrc</code> 或者 <code>.bashrc</code> 添加以下配置，<code>.Trash</code> 是Mac下的废纸篓目录。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">alias rm=trash</span><br><span class="line">alias r=trash</span><br><span class="line">alias rl='ls ~/.Trash'</span><br><span class="line">alias ur=undelfile</span><br><span class="line">undelfile()</span><br><span class="line">&#123;</span><br><span class="line">    mv -i ~/.Trash/$@ ./</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rm</code> 或 <code>r</code> 命令可以把文件或者文件夹移入废纸篓。</p>
<p><code>rl</code> 罗列出废纸篓内的文件。</p>
<p><code>ur</code> 把废纸篓内的某个文件移动到当前位置，相当于恢复。</p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单的WebSocket聊天室</title>
    <url>/2019/04/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84WebSocket%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    <content><![CDATA[<h2 id="WebSocket-简介"><a href="#WebSocket-简介" class="headerlink" title="WebSocket 简介"></a>WebSocket 简介</h2><blockquote>
<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。<br>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。<br>在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。</p>
</blockquote>
<!--more-->
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>我们先用 <code>express</code> 搭一个基础的服务端。</p>
<p>创建 <code>index.js</code> 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(app);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">'&lt;h1&gt;Hello world&lt;/h1&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on *:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>run <code>node index.js</code>，并在浏览器打开 <code>http://localhost:3000</code>，访问成功即可看到</p>
<p><img data-src="http://cdn.chaohang.top/20200121113457.png" alt=""></p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>设计我们的主页，实现一个简单的聊天窗口。</p>
<p>修改 <code>index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>创建 <code>index.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Socket.IO chat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      * &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">box-sizing</span>: border-box; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">body</span> &#123; <span class="attribute">font</span>: <span class="number">13px</span> Helvetica, Arial; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">form</span> &#123; <span class="attribute">background</span>: <span class="number">#000</span>; <span class="attribute">padding</span>: <span class="number">3px</span>; <span class="attribute">position</span>: fixed; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">form</span> <span class="selector-tag">input</span> &#123; <span class="attribute">border</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">width</span>: <span class="number">90%</span>; <span class="attribute">margin-right</span>: .<span class="number">5%</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">form</span> <span class="selector-tag">button</span> &#123; <span class="attribute">width</span>: <span class="number">9%</span>; <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">130</span>, <span class="number">224</span>, <span class="number">255</span>); <span class="attribute">border</span>: none; <span class="attribute">padding</span>: <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#messages</span> &#123; <span class="attribute">list-style-type</span>: none; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#messages</span> <span class="selector-tag">li</span> &#123; <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#messages</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(odd)</span> &#123; <span class="attribute">background</span>: <span class="number">#eee</span>; &#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"messages"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"m"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> /&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重启应用并刷新页面你就可以看到一个如下图所示</p>
<p><img data-src="http://cdn.chaohang.top/20200121113537.png" alt=""></p>
<h2 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h2><p>引入<code>socket.io</code></p>
<p><code>npm install --save socket.io</code></p>
<p>修改 <code>index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'an user connected'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on *:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>修改 <code>index.html</code>，在<code>&lt;/body&gt;</code>下添加如下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> socket = io();</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重启应用并刷新页面，就可以看到命令行打印如下</p>
<p><img data-src="http://cdn.chaohang.top/20200121113638.png" alt=""></p>
<h2 id="Emitting-event"><a href="#Emitting-event" class="headerlink" title="Emitting event"></a>Emitting event</h2><p>当用户在聊天窗的输入框内输入，并提交时，触发 <code>emit</code> 事件，服务端监听到该事件并做出相应的反应。</p>
<p>修改 <code>index.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-1.11.1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = io();</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">      e.preventDefault(); <span class="comment">// 防止页面重新加载</span></span></span><br><span class="line"><span class="javascript">      socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val());</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'#m'</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务端监听该事件，在 <code>index.js</code> 文件添加该代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'message: '</span> + msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="展示消息"><a href="#展示消息" class="headerlink" title="展示消息"></a>展示消息</h2><p>当服务端收到用户A发出的消息，服务端重新发出该消息，让客户端接收，客户端监听到该事件后展示该条消息，就可以实现用户 A, B, C 都接收到该消息。</p>
<p>修改 <code>index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    io.emit(<span class="string">'chat message'</span>, msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>修改 <code>index.html</code>，实现消息的展示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = io();</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">      e.preventDefault(); <span class="comment">// prevents page reloading</span></span></span><br><span class="line"><span class="javascript">      socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val());</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'#m'</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(msg)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'#messages'</span>).append($(<span class="string">'&lt;li&gt;'</span>).text(msg));</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重启应用并刷新页面，可以打开多个浏览器页面同时访问 <code>localhost:3000</code>，就可以体验简单聊天室的效果。</p>
<p><img data-src="http://cdn.chaohang.top/20200121113554.png" alt=""></p>
<h2 id="设置昵称"><a href="#设置昵称" class="headerlink" title="设置昵称"></a>设置昵称</h2><p> 在每个用户进入的时候，随机生成一个数字作为用户的昵称，并且向所有用户广播该用户进入聊天室。当用户发送消息时，拼接上用户的昵称。</p>
<p>修改 <code>index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> nickname = <span class="string">'user'</span> + <span class="built_in">Math</span>.ceil((<span class="built_in">Math</span>.random() * <span class="number">1000</span>))</span><br><span class="line">  socket.broadcast.emit(<span class="string">'connection'</span>, nickname + <span class="string">' connected'</span>)</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">'chat message'</span>, (msg) =&gt; &#123;</span><br><span class="line">    io.emit(<span class="string">'chat message'</span>, nickname + <span class="string">': '</span> + msg)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>修改 <code>index.html</code>，监听 <code>connection</code> 事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(() =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> socket = io()</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'form'</span>).submit(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line">        e.preventDefault()</span><br><span class="line"><span class="javascript">        socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val())</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#m'</span>).val(<span class="string">''</span>)</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="actionscript">      socket.on(<span class="string">'chat message'</span>, (msg) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#messages'</span>).append($(<span class="string">'&lt;li&gt;'</span>).text(msg))</span></span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      socket.on(<span class="string">'connection'</span>, (msg) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#messages'</span>).append($(<span class="string">'&lt;li&gt;'</span>).text(msg))</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重启应用并打开多个客户端，可以看到如下效果</p>
<p><img data-src="http://cdn.chaohang.top/20200121113659.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文大部分案例出自 <code>socket.io</code> 的入门文档 <a href="https://socket.io/get-started/chat/" target="_blank" rel="noopener">https://socket.io/get-started/chat/</a></p>
<p><a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/WebSocket</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001472780997905c8f293615c5a42eab058b6dc29936a5c000" target="_blank" rel="noopener">廖雪峰官网 WebSocket</a></p>
<p><a href="http://www.runoob.com/html/html5-websocket.html" target="_blank" rel="noopener">菜鸟教程 WebSocket</a></p>
]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>微信支付开发实记</title>
    <url>/2018/11/19/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%BC%80%E5%8F%91%E5%AE%9E%E8%AE%B0/</url>
    <content><![CDATA[<p>微信支付分为JSAPI支付，扫码支付，APP支付，小程序支付等不同的支付方式。但大体的支付过程是一致的，本文以JSAPI支付，也就是微信内的H5支付为例，描述一下支付的整个开发流程。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>商户需要提前开通商户平台，并去公众平台或开放平台提交微信支付申请，获得商户号和秘钥。</p>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=3_1" target="_blank" rel="noopener">详细文档可以看这里</a></p>
<a id="more"></a>
<h2 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h2><p><img data-src="http://cdn.chaohang.top/20200121113820.png" alt="微信内网页支付时序图"></p>
<p>微信支付的流程图画的很完整，开发前要把整个流程研究清楚。</p>
<p>整个流程，服务端需要做的有三件事。</p>
<ol>
<li>前端支付按钮被触发后，服务端要去调用 <a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1" target="_blank" rel="noopener">统一下单</a> 接口，把预付单信息、支付参数和参数签名返回给前端。前端根据这些参数唤起支付。</li>
<li>当用户支付成功后，微信会给我们一个回调通知，告知我们支付结果。这一步要实现“完成订单”操作，标记用户已经成功支付，进入“发货”流程。</li>
<li>提供一个查询接口，让前端再次确认是否支付成功。</li>
</ol>
<h2 id="统一下单"><a href="#统一下单" class="headerlink" title="统一下单"></a>统一下单</h2><p>在支付前，商户系统先调用该接口在微信支付后台生成预支付交易单，同样的，商户系统也需要在自己的表里记录一笔“未完成订单”。生成之后返回正确的预付单信息、支付参数和参数签名返回给前端。前端根据这些参数唤起支付。</p>
<p>接口</p>
<p><code>https://api.mch.weixin.qq.com/pay/unifiedorder</code><br><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1" target="_blank" rel="noopener">参数巨多，具体还是看文档</a></p>
<p>这里需要说明的一点是，我们在调用这个接口时，需要签一次名用来给微信做校验，微信也返回了一个新的签名用来给我们做校验，然后我们还要返回给前端一个签名，用来唤起支付。这三个签名都不是同一个。</p>
<p>我们不能直接把调用统一下单接口返回的签名返回给前端，而是<strong>根据前端唤起支付的参数去重新签名</strong>。</p>
<p>注意，是<strong>根据前端唤起支付的参数去重新签名</strong>，因为前端的参数名和后端的参数名会略微有差别，这里需要小心。</p>
<p>说明：签名的意图是用来校验身份，当前端把这些参数传给微信，微信会把调用参数除去签名后重新签名，用来校验签名的正确性，所以用来签名的参数名要和前端参数一致。</p>
<h2 id="支付结果通知"><a href="#支付结果通知" class="headerlink" title="支付结果通知"></a>支付结果通知</h2><p>在统一下单时我们填了一个参数叫 <code>notify_url</code>，这是一个服务端的接口地址，微信在用户支付成功后，会回调这个地址，告知我们支付结果。</p>
<p><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_7&amp;index=8" target="_blank" rel="noopener">详情看文档</a></p>
<p>在这一步还是需要做多点校验的，免得被人有机可乘。</p>
<ol>
<li>校验支付是否成功，不成功直接返回”FAIL”</li>
<li>校验签名和appid</li>
<li>校验订单是否完成(幂等校验，防止微信多次回调导致多次订单写入)</li>
<li>订单金额校验</li>
</ol>
<p>一通校验完事之后就可以做业务相关的事了。记得所有操作结束后返回”SUCCESS”，不然微信会不断发起回调。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>流程图描述的很清楚，要仔细阅读流程图。</li>
<li>调用完下单接口后要进行二次签名，签名的参数要看前端验签用哪些参数，即使是同一个参数，字段名也会跟第一次加签不一样。</li>
<li>前端支付完成之后微信会有一个回调，我们需要做以下几点校验：<ol>
<li>做幂等处理（因为同样的通知微信可能发送多次）。</li>
<li>校验签名，校验APPID。</li>
<li>校验订单金额。</li>
</ol>
</li>
<li>订单状态分为 0-未支付 1-支付完成 2-支付失败：<ol>
<li>用户触发支付组件然后关闭或者杀掉进程微信不会给到后台任何回复，始终处于 0-未支付，所以这个状态也是一个支付失败状态。</li>
<li>支付失败比较少见（到现在没有遇到过），比如签名错误（发生在调试阶段）。</li>
</ol>
</li>
<li>微信回执表尽量详细的记录微信传回的所有必有参数，以备出问题时排查，可以直接丢到mongodb里。</li>
</ol>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>微信网页授权</title>
    <url>/2018/11/19/%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li><p>在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</p>
</li>
<li><p>授权回调域名配置规范为全域名，比如需要网页授权的域名为：<a href="http://www.qq.com，配置以后此域名下面的页面" target="_blank" rel="noopener">www.qq.com，配置以后此域名下面的页面</a><a href="http://www.qq.com/music.html" target="_blank" rel="noopener">http://www.qq.com/music.html</a> 、 <a href="http://www.qq.com/login.html" target="_blank" rel="noopener">http://www.qq.com/login.html</a> 都可以进行OAuth2.0鉴权。但<a href="http://pay.qq.com/" target="_blank" rel="noopener">http://pay.qq.com</a> 、 <a href="http://music.qq.com/" target="_blank" rel="noopener">http://music.qq.com</a> 、 <a href="http://qq.xn--comoauth2-735sh62dwk9eysua.xn--0-k76bu98j/" target="_blank" rel="noopener">http://qq.com无法进行OAuth2.0鉴权</a></p>
</li>
</ol>
<a id="more"></a>
<h2 id="两种授权方式"><a href="#两种授权方式" class="headerlink" title="两种授权方式"></a>两种授权方式</h2><p>微信提供了两种授权方式来应对不同的使用场景。通过网页授权作用域 <code>scope</code> 参数控制。</p>
<h3 id="静默授权"><a href="#静默授权" class="headerlink" title="静默授权"></a>静默授权</h3><ol>
<li><strong>静默授权</strong>：用户进入页面后自动授权并跳转回页面，这种授权对用户无感知。通过这种授权我们只能获取到用户的 <code>openid</code>，无法获得用户的其他信息。</li>
<li>使用场景：只需要标识该用户，而不需要收集其他信息的场景都可以使用。比如投票、点赞等场景。</li>
<li><code>scope: snsapi_base</code></li>
</ol>
<h3 id="主动授权"><a href="#主动授权" class="headerlink" title="主动授权"></a>主动授权</h3><ol>
<li><strong>主动授权</strong>：用户进入页面后会有授权弹窗，需要手动同意。该方试用来获取用户的基本信息</li>
<li>注意：<strong>对于已关注公众号的用户，</strong>用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是<code>scope: snsapi_userinfo</code>，也是静默授权，用户无感知。</li>
<li><code>scope: snsapi_userinfo</code></li>
</ol>
<h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><ol>
<li>用户进入页面，获取 <code>code</code></li>
<li>通过 <code>code</code> 换取网页授权 <code>access_token</code> 和 <code>openid</code>，静默授权到这步结束</li>
<li>通过 <code>access_token</code> 获取用户信息</li>
</ol>
<h3 id="获取CODE"><a href="#获取CODE" class="headerlink" title="获取CODE"></a>获取CODE</h3><p>引导用户跳传至该链接</p>
<p><code>https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE</code></p>
<p>用户同意授权或静默授权后将跳转至  <code>redirect_url?code=CODE&amp;state=STATE</code> 这个地址并带上生成的 <code>code</code>。</p>
<p><code>code</code> 作为换取<code>access_token</code>的票据，只能使用一次，5分钟未使用自动过期。</p>
<p>参数说明</p>
<p><img data-src="http://cdn.chaohang.top/20200121113934.png" alt=""></p>
<h3 id="通过-code-换取网页授权-access-token"><a href="#通过-code-换取网页授权-access-token" class="headerlink" title="通过 code 换取网页授权 access_token"></a>通过 <code>code</code> 换取网页授权 <code>access_token</code></h3><p>注意，这里的 <code>access_token</code> 和 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="noopener">调用公众平台API所需的基础 <code>access_token</code></a>不是一个东东，只是名字一样而已。</p>
<p>这一步是在服务端完成的，需要公众号的 <code>secret</code>，<code>access_token</code> 也不可以传给客户端。</p>
<p>请求接口</p>
<p><code>https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</code></p>
<p><img data-src="http://cdn.chaohang.top/20200121114006.png" alt=""></p>
<p>返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">  &quot;expires_in&quot;:7200,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">  &quot;openid&quot;:&quot;OPENID&quot;,</span><br><span class="line">  &quot;scope&quot;:&quot;SCOPE&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://cdn.chaohang.top/20200121114057.png" alt=""></p>
<h3 id="拉取用户信息（需scope为snsapi-userinfo）"><a href="#拉取用户信息（需scope为snsapi-userinfo）" class="headerlink" title="拉取用户信息（需scope为snsapi_userinfo）"></a>拉取用户信息（需scope为snsapi_userinfo）</h3><p>当网页授权作用域为 <code>snsapi_userinfo</code>时，开发者通过 <code>access_token</code> 和 <code>openid</code> 获取用户信息。</p>
<p>请求接口</p>
<p><code>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</code></p>
<p><img data-src="http://cdn.chaohang.top/20200121114113.png" alt=""></p>
<p>返回</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">"openid"</span>: <span class="string">"OPENID"</span>,</span><br><span class="line">  <span class="attr">"nickname"</span>: <span class="string">"NICKNAME"</span>,</span><br><span class="line">  <span class="attr">"sex"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"province"</span>: <span class="string">"PROVINCE"</span></span><br><span class="line">  <span class="string">"city"</span>: <span class="string">"CITY"</span>,</span><br><span class="line">  <span class="attr">"country"</span>: <span class="string">"COUNTRY"</span>,</span><br><span class="line">  <span class="attr">"headimgurl"</span>:    <span class="string">"http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46"</span>,</span><br><span class="line">  <span class="attr">"privilege"</span>: [ <span class="string">"PRIVILEGE1"</span> <span class="string">"PRIVILEGE2"</span>     ],</span><br><span class="line">  <span class="attr">"unionid"</span>: <span class="string">"o6_bmasdasdsad6_2sgVt7hMZOPfL"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="http://cdn.chaohang.top/20200121114129.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">微信网页授权官方文档</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序登录及用户信息和手机号的获取</title>
    <url>/2018/11/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E5%8F%8A%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%92%8C%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%9A%84%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<h2 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h2><p><img data-src="http://cdn.chaohang.top/20200212112929.png" alt="登录流程"></p>
<ol>
<li>小程序通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html" target="_blank" rel="noopener"><code>wx.login</code></a> 获取 <code>code</code>(用户登录凭证，有效期五分钟，使用一次后实效)</li>
<li>服务端拿到 <code>code</code>，调用 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/code2Session.html" target="_blank" rel="noopener"><code>code2Session</code></a>，获取用户的 <code>openid</code> (用户在当前应用的唯一标识)、<code>unionid</code> (用户在开发平台的唯一标识) <code>session_key</code> (会话秘钥是对用户数据进行 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html" target="_blank" rel="noopener">加密签名</a> 的秘钥，在获取用户信息时会用到) 等信息。为了安全，服务器<strong>不应该把会话秘钥下发到小程序，也不应该对外提供这个秘钥</strong></li>
<li>通过 <code>unionid</code> <code>openid</code> 自定义服务端登录态</li>
</ol>
<a id="more"></a>
<h2 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h2><ol>
<li>用户授权后，小程序通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html" target="_blank" rel="noopener"><code>wx.getUserInfo</code></a> 获取用户信息，敏感信息被加密</li>
<li>把加密信息传给服务端，使用在登录时获取的 <code>session_key</code> 解密数据，解密方法可以看微信的 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html" target="_blank" rel="noopener">开放数据校验与解密文档</a></li>
</ol>
<h2 id="获取手机号"><a href="#获取手机号" class="headerlink" title="获取手机号"></a>获取手机号</h2><p>需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 <code>&lt;button&gt;</code> 组件的点击来触发。<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html" target="_blank" rel="noopener">获取手机号文档</a>。</p>
<ol>
<li>小程序通过 <code>&lt;button&gt;</code> 组件触发 <code>getPhoneNumber</code> 事件，获得加密后的信息</li>
<li>把加密信息传给服务端，使用在登录时获取的 <code>session_key</code> 解密数据，获得用户绑定的手机号</li>
</ol>
<p>下面是我实际开发中画的一张前后端交互的流程图，欢迎指出不足指出。</p>
<p><img data-src="http://cdn.chaohang.top/20200212113003.png" alt="获取用户手机号，前后端交互流程"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/" target="_blank" rel="noopener">小程序开发文档</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 获取微信JS-SDK CONFIG</title>
    <url>/2018/11/07/Node-js-%E8%8E%B7%E5%8F%96%E5%BE%AE%E4%BF%A1JS-SDK-CONFIG/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前端在调用微信提供的分享、拍照、扫一扫等功能时需要到后台获取配置，主要是签名(signature)。Node 开发可以用朴灵大佬的SDK——<a href="https://github.com/node-webot/co-wechat-api" target="_blank" rel="noopener">co-wechat-api</a>。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>到微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。前提是该域名的项目目录下有微信提供的校验文件。如果需要本地调试或者测试环境调试，可以把IP白名单也顺便配置一下。</p>
<a id="more"></a>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>实例化 <code>WechatAPI</code> 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WECHAT_API = <span class="keyword">new</span> WechatAPI(</span><br><span class="line">  appid,</span><br><span class="line">  secret,</span><br><span class="line">  get_access_token,  <span class="comment">// function</span></span><br><span class="line">  save_access_token,  <span class="comment">// function 缓存 access_token</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">WECHAT_API.registerTicketHandle(</span><br><span class="line">  get_js_api_ticket,  <span class="comment">// function</span></span><br><span class="line">  save_js_api_ticket,  <span class="comment">// function 缓存 jsapi_ticket</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>jsapi_ticket</code> 是公众号用于调用微信JS接口的临时票据。正常情况下，<code>jsapi_ticket</code> 的有效期为7200秒，通过 <code>access_token</code> 来获取。由于获取 <code>jsapi_ticket</code> 的api调用次数非常有限，频繁刷新 <code>jsapi_ticket</code> 会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存 <code>jsapi_ticket</code>。同样的，<code>access_token</code> 有效期也是7200秒，同样需要全局缓存。</p>
<p>缓存的函数就是简单的 <code>JSON.stringify</code> 后存入 redis 或其他数据库。</p>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">      debug: <span class="literal">false</span>,</span><br><span class="line">      jsApiList: [],  <span class="comment">// 需要获取的能力，由前端传入</span></span><br><span class="line">      url: <span class="string">''</span>,        <span class="comment">// 申请能力并且在后台配置过的域名</span></span><br><span class="line">&#125;;</span><br><span class="line">ctx.body = <span class="keyword">await</span> WECHAT_API.getJsConfig(params);</span><br></pre></td></tr></table></figure>
<h2 id="接入多个微信公众号"><a href="#接入多个微信公众号" class="headerlink" title="接入多个微信公众号"></a>接入多个微信公众号</h2><p>待我重构归来。。。。。。</p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>wechat</tag>
        <tag>node.js</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>代码顺序的重要性</title>
    <url>/2018/11/07/%E4%BB%A3%E7%A0%81%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在修改前辈留下来的代码时踩到一个坑。简单讲一下代码做了什么事：在 try/catch 里实例化多个类，并调用类的方法为其赋值，catch 到错误也不会中断，而是通过打日志的形式收集报错信息。</p>
<p>我需要在里面新实例化一个类，有样学样，上来就是一顿copy改，可是新增的类的某个属性总是不对，排查了半天才发现一个坑。</p>
<a id="more"></a>
<h2 id="错误模拟"><a href="#错误模拟" class="headerlink" title="错误模拟"></a>错误模拟</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getX() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setX(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p, cat</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  cat = <span class="keyword">new</span> Cat(<span class="string">'胖虎'</span>)  <span class="comment">// 这里实例化了一个不存在的类，用来模拟报错，实际情况比这个复杂</span></span><br><span class="line"></span><br><span class="line">  p.setX(<span class="number">66</span>)  <span class="comment">//  这一行应该写在 `cat` 的前面，不然 `cat` 报错后直接中断下面语句的执行，导致这行语句没有执行</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.getX())</span><br></pre></td></tr></table></figure>
<p>执行结果，<code>x</code> 没有被赋值成66，抛出错误导致程序中断，赋值语句没有执行</p>
<p><img data-src="http://cdn.chaohang.top/20200212113234.png" alt="执行结果"></p>
<h2 id="正确的写法"><a href="#正确的写法" class="headerlink" title="正确的写法"></a>正确的写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getX() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setX(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p, cat</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  p.setX(<span class="number">66</span>)  <span class="comment">// 方法调用紧随实例后面，不受下面代码的影响</span></span><br><span class="line"></span><br><span class="line">  cat = <span class="keyword">new</span> Cat(<span class="string">'胖虎'</span>)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.getX())</span><br></pre></td></tr></table></figure>
<p>执行结果，<code>x</code> 正确被赋值，错误也正常抛出</p>
<p><img data-src="http://cdn.chaohang.top/20200212113254.png" alt="执行结果"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>如果 catch 了错误又不抛出，可以在调试的时候把错误抛出，方便发现问题。</li>
<li>代码结构顺序和整洁性很重要。</li>
<li>如果出现这种傻瓜式错误，是该考虑重构代码了。</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛视频防盗链处理</title>
    <url>/2018/11/02/%E4%B8%83%E7%89%9B%E8%A7%86%E9%A2%91%E9%98%B2%E7%9B%97%E9%93%BE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司在做付费课程，视频教学为主，需要对视频链接作防盗链处理。</p>
<h2 id="REFERER"><a href="#REFERER" class="headerlink" title="REFERER"></a>REFERER</h2><p>HTTP referer 是 header 上的一个属性。当浏览器向服务器发起请求时，一般会带上Referer，告诉服务器我是从哪个页面链接过来的。</p>
<p>七牛在融合 CDN -&gt; 域名管理 -&gt; 高级配置里有一个域名防盗链选项。</p>
<p><img data-src="http://cdn.chaohang.top/20200212113323.png" alt="域名防盗链"></p>
<p>配置好之后就可以限制链接只能从配置好的白名单域名进行访问，简单的防御了盗链。但是HTTP header 是可以被伪造的，经测试，直接用 postman 加个 Referer 就可以绕过了。</p>
<a id="more"></a>
<h2 id="私有空间"><a href="#私有空间" class="headerlink" title="私有空间"></a>私有空间</h2><p>七牛云提供了私有空间，空间内的文件对象都要获得拥有者的授权才能进行访问，并且可以设置链接的有效时间，超过时长后自动失效（视频会有缓存，清空缓存之前视频仍然有效）。</p>
<p>如何创建私有空间的访问链接，下面是 Node.js SDK 的一段示例代码，其他语言可以去官网查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mac &#x3D; new qiniu.auth.digest.Mac(accessKey, secretKey);</span><br><span class="line">var config &#x3D; new qiniu.conf.Config();</span><br><span class="line">var bucketManager &#x3D; new qiniu.rs.BucketManager(mac, config);</span><br><span class="line">var privateBucketDomain &#x3D; &#39;http:&#x2F;&#x2F;if-pri.qiniudn.com&#39;;</span><br><span class="line">var deadline &#x3D; parseInt(Date.now() &#x2F; 1000) + 3600; &#x2F;&#x2F; 1小时过期</span><br><span class="line">var privateDownloadUrl &#x3D; bucketManager.privateDownloadUrl(privateBucketDomain, key, deadline);</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>测试域名不能用于私有空间。</li>
<li>自定义域名必须开启回源鉴权。</li>
<li>播放 hls 文件需要使用 pm3u8 服务。</li>
</ol>
<p>详情可见这里：<a href="https://developer.qiniu.com/kodo/kb/4054/matters-needing-attention-of-private-space" target="_blank" rel="noopener">私有空间的注意事项</a>。</p>
<h3 id="PM3U8"><a href="#PM3U8" class="headerlink" title="PM3U8"></a>PM3U8</h3><p>视频切片(<a href="https://www.jianshu.com/p/f2d4e3187ce5" target="_blank" rel="noopener">七牛视频切片</a>)后放在私有仓库时，获取单段视频的链接也需要带上token。七牛提供了 <a href="https://developer.qiniu.com/dora/manual/1292/private-m3u8-pm3u8" target="_blank" rel="noopener">pm3u8服务</a> ，对 m3u8文件中的 ts 资源进行批量下载授权。通过将 ts 资源的 url 改写成私有 url，以临时获取访问权限。</p>
<p>有个需要注意的地方是，做签名处理时，要对整个链接做签名，比如 <code>https://test.com/12354.m3u8?pm3u8/0</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var privateBucketDomain &#x3D; &#39;http:&#x2F;&#x2F;if-pri.qiniudn.com&#39;;</span><br><span class="line">var deadline &#x3D; parseInt(Date.now() &#x2F; 1000) + 3600; &#x2F;&#x2F; 1小时过期</span><br><span class="line"></span><br><span class="line">var key &#x3D; 12354.m3u8?pm3u8&#x2F;0;  &#x2F;&#x2F; pm3u8 参数和 url 一起做签名</span><br><span class="line"></span><br><span class="line">var privateDownloadUrl &#x3D; bucketManager.privateDownloadUrl(privateBucketDomain, key, deadline);</span><br></pre></td></tr></table></figure>
<p>还有个需要注意的地方是，虽然官方文档有一句这种提示，但和七牛沟通后的结果是，pm3u8 服务也是支持 <code>https</code> 的。</p>
<p><img data-src="http://cdn.chaohang.top/20200212113415.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 REFERER + 私有空间 已经可以解决盗链问题了，但是如果视频被下载仍然是个问题。需要对视频做加密处理，但是即使做了加密处理，也阻止不了录屏。完全杜绝视频泄露是很难的，或者我们可以采取其他方式加大盗用的成本，比如在视频里加上水印或者观看者ID，甚至让水印或者观看者ID在视频里四处游走（影响观看体验）。</p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>JavaScript</tag>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title>白夜行</title>
    <url>/2018/10/31/%E7%99%BD%E5%A4%9C%E8%A1%8C/</url>
    <content><![CDATA[<blockquote>
<p>“我呢，”雪穗继续说，“从来就没有生活在太阳底下。”<br> “我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吗？我从来没有太阳，所以不害怕失去。” ——《白夜行》东野圭吾。</p>
</blockquote>
<p><img data-src="http://cdn.chaohang.top/20200212113836.png" alt="《白夜行》"></p>
<p>开头是一宗离奇的命案，调查以无任何结果告终。然后开始分别叙述两位主人公的生活。从十一岁到初中到高中到成人，时间跨度长达十九年。每一件事单独看都是一个精彩的故事，谁知道最后所有的事情都会串起来成为解答开头命案的线索。本来以为是两个互不相关的两个人，作者在分别叙述他们的故事，看起来毫无相关性。看到最后才知道两个人始终在一起，策划着每一个意外。</p>
<a id="more"></a>
<p>大师就是大师，把这么多繁复的事情一一叙述，中间用一条几乎不可见的线串联起来，看到最后只能张大嘴巴惊讶，原来竟是这样。</p>
<p>本来以为唐泽雪穗是一步一步黑化，其实在她十一岁被母亲卖给一个个男人，她的灵魂就已经被夺走了。她也用同样的方法夺走了三个女孩的灵魂，同时又达到自己的目的。而桐原亮司是一直爱着她的，他总是在人们看不见的地方守护雪穗。书的结尾描写他装扮成圣诞老人在雪穗新开的店里，应该是书中第一次描写两人同时出现在同一个地点，也是最后一次。被警察发现后抱着必死的决心跳楼，怕跳楼可能死不了还用自己心爱的剪刀插在心脏。桐原亮司要杀一个人确实从未失手过，包括他自己。</p>
<p>看一遍没办法看清细节，更何况我是有空才看一二十分钟，前后文间隔时间有点长，有的情节容易忘掉。下次再看一定要捧着实体书，在一个有阳光的午后，一次性看完。不过再次看时已经知道了每个人物身份每个情节，应该没了第一次看时的惊讶和刺激了吧。那就等我把情节忘记得差不多的时候，再重新读一遍吧。</p>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>《码农翻身》读书笔记</title>
    <url>/2018/10/28/%E3%80%8A%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>花了一天时间翻完了《码农翻身》（跳过了Java部分）。生动有趣的书看起来就是舒服，竟有引人入胜、手不释卷的感觉，一不小心就翻完了。是一本很好的入门科普读物，开阔技术视野。</p>
<p>下面是书中的摘抄和笔记</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=416915373&amp;idx=1&amp;sn=f80a13b099237534a3ef777d511d831a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我是一个线程</a></p>
<ol>
<li>不知道什么时候会被挑中执行</li>
<li>在执行的过程中随时可能被打断，让出CPU</li>
<li>一旦出现硬盘、数据库这样耗时的操作，也得让出CPU</li>
<li>数据来了，也不一定马上执行，还得等着被CPU挑选</li>
</ol>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513375&amp;idx=1&amp;sn=e11745d5cb28fa1f89465f8d0e5fae1a&amp;chksm=80d679dcb7a1f0cadec0a1db45b3fa3f6eabde4a9e56a77acf551fbc1511e6b8f055ee2c97e3&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">TCP/IP之大明内阁</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513384&amp;idx=1&amp;sn=82c45e4430618270a744e212d2f57990&amp;chksm=80d679ebb7a1f0fd27fe1814765a0e60b1c293ca4e09403271b4bb3f38f317439956fdca1bc1&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">TCP/IP之蓟辽督师</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513094&amp;idx=1&amp;sn=a2accfc41107ac08d74ec3317995955e&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">TCP/IP 之 大明王朝邮差</a></p>
<p><img data-src="http://cdn.chaohang.top/20200212113500.png" alt="三次握手"></p>
<p>发送的信息被拆分成小包裹，编上序号，打乱顺序后发送，由服务端发送，客户端接收，接收后返回确认接收信息。如果一定时间内没有收到确认信息，则代表信息丢失（可能是发出的包裹丢失，也可能是返回的确认信息丢失），重新发送该包裹。全部接收完成后按照序号重新组装成完整信息。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513779&amp;idx=1&amp;sn=a1de58690ad4f95111e013254a026ca2&amp;chksm=80d67b70b7a1f26697fa1626b3e9830dbdf4857d7a9528d22662f2e43af149265c4fd1b60024&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">一个故事讲完https</a></p>
<a id="more"></a>
<p>这里面讲HTTPS讲的非常好，通俗易懂有趣。</p>
<p><img data-src="http://cdn.chaohang.top/20200212113554.png" alt=""></p>
<p><img data-src="http://cdn.chaohang.top/20200212113612.png" alt=""></p>
<p>bill的公钥及身份信息通过HTTPS传输给CA服务器，并生成数字证书。</p>
<p><img data-src="http://cdn.chaohang.top/20200212113656.png" alt=""></p>
<p>验证完证书后，除了对称秘钥是用非对称加密传输，其他请求都使用对称加密通信。</p>
<h4 id="如何确保CA公钥的安全"><a href="#如何确保CA公钥的安全" class="headerlink" title="如何确保CA公钥的安全"></a>如何确保CA公钥的安全</h4><p>ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。</p>
<h3 id="OTHER"><a href="#OTHER" class="headerlink" title="OTHER"></a>OTHER</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513725&amp;idx=1&amp;sn=bdad37137c3660953511410c289edc86&amp;chksm=80d67abeb7a1f3a8cd8c62cfb3914aa9e1a425ce4986ec812c2e77c4ef8a10aab006032735b9&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">机房夜话</a></p>
<p>单点登录也讲得妙趣横生</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513744&amp;idx=1&amp;sn=93d0db97cfd67422bcd21c8afd00f495&amp;chksm=80d67b53b7a1f24537fdc7c10eb2783357c1f8c65ad55601a722216d2293ae3fb7b1c16e5449&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">从密码到token， 一个授权的故事</a></p>
<p>第三方授权，接入微信服务会经常用到。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513387&amp;idx=1&amp;sn=99665948d0b968cf15c5e7a01ffe166c&amp;chksm=80d679e8b7a1f0febad077b57e8ad73bfb4b08de74814c45e1b1bd61ab4017b5041942403afb&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">张大胖的socket</a></p>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>为了区分同一台服务器的不同进程。<br>进程号是动态的，如果服务器端的进程重启了，进程号就变了。端口号就是从来标识服务器端的进程。</p>
<h3 id="老司机的忠告"><a href="#老司机的忠告" class="headerlink" title="老司机的忠告"></a>老司机的忠告</h3><ol>
<li>凡事必先骑虎上背</li>
<li>局部性原理<br>（1）时间局部性：如果程序中的某条指令一旦执行，则不久之后该条指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。<br>（2）空间局部性：是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。</li>
<li>抽象是计算机科学中极为重要的武器之一</li>
<li>要透彻地理解一门技术的本质</li>
<li>写漂亮的代码</li>
<li>书籍里的知识，体系更加完整，有深度——看书好过碎片阅读</li>
<li>不要游走在各大语言的边缘</li>
<li>坚持写作（输出）</li>
</ol>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>看见</title>
    <url>/2018/10/20/%E7%9C%8B%E8%A7%81/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200212113904.png" alt="《看见》"></p>
<p>花了半个月断断续续看完了柴静的《看见》。这本书值得重新再看一次。</p>
<p>这次看这本书，用手机看，一目十行，有时候看着看着走神了，有时候动动手指就多翻了几页，或者在电梯里地铁里吃饭排队时匆匆看两眼。碎片时间让文章没了上下文，没了沉浸感。用手机看书是方便，随时随地，但不适合看一些有深度的书。</p>
<p>这本书是一个时代的记忆——非典，汶川地震，奥运。也记录了各式各样的人和群体——双城集体服毒的小学生，戒毒所里被卖去卖淫的女人，采访同性恋，不知道犯了什么罪就被关了二十八年的人，因家庭暴力杀死丈夫的女人，山西的环境污染，采访用高跟鞋踩死小猫拍成视频传到网上的女人，华南虎照片真假事件，福建涂岭拆迁户不同意搬迁，户主的儿子——一个刚复员回来的年轻人，二十三岁——被开发商砍死，农村征地问题，采访卢安克，药家鑫事件。</p>
<a id="more"></a>
<p>还有她的恩师，陈虻。严苛，多批评很少夸奖，又恰好激发了潜力和斗志。能够遇到这样的引路人，我们只有羡慕的份。</p>
<p>这么多事情里，贯穿这本书的是：如何做一个合格的记者。书到结尾，没有答案，而是作者每个阶段对记者不同的理解。</p>
<p>是不是应该客观不带丝毫感情，要引导采访对象而不是咄咄逼问。要如何做一个记者，让形形色色的人愿意在你面前，在镜头面前吐露心声。如何知道得到的回答是受访者的本意，而非受记者有意引导。</p>
<p>往大了讲，如何辨别真假新闻——这是连特朗普都头疼的事。对于这个问题我就不敢乱说了，带着怀疑的态度看问题，有调查的新闻才是好新闻。</p>
<p>之前没有看过柴进的报道，特地去找了一集看一下。《双城的创伤》，小孩的内心世界往往比想象中的复杂，在心智还没完全成熟的时候，一些事对孩子来说可能是很大很难的事。柴静在采访结尾说：”双城事件调查到最后，我们发现，最大的迷，其实是孩子的内心世界，能不能打开它，可能是每个人都需要面对的问题。”</p>
<h3 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h3><blockquote>
<p>人们声称的最美好的岁月其实都是最痛苦的</p>
</blockquote>
<blockquote>
<p>无卷宗，无判决，无罪名，无期限。他被关了二十八年。</p>
</blockquote>
<blockquote>
<p>在中国，一个男人仍然可以打一个女人，用刀砍她的手，用酒瓶子扎她的眼睛，用枪抵住她的后背，强暴她的姐妹，殴打她的孩子。他甚至在众人面前这样子做，不会受到惩罚——只因为他是她的丈夫。</p>
</blockquote>
<blockquote>
<p>开始是不宣布对军队与政府不利的消息，后来发展为对军队和政府有利的消息要大力宣传。那些敢于坚持独立性、发出不同声音的报业成为受害者。</p>
</blockquote>
<blockquote>
<p>不再坐在教室里被动地接收别人灌输给我的东西了，而是主动地去了解。你们这些真正了解战争的人，请多告诉我们一些。</p>
</blockquote>
<blockquote>
<p>钱老师送这本书给我，我明白他当年让我读历史的原因：“新旧之间没有怨讼，唯有真与伪是大敌。”</p>
</blockquote>
<blockquote>
<p>宽容的基础是理解，你理解吗？</p>
</blockquote>
<blockquote>
<p>你有自己认识事物的坐标体系吗？</p>
</blockquote>
<blockquote>
<p>不要用道德的眼光看经济问题。</p>
</blockquote>
<blockquote>
<p>专制就是坚信自己是不会错的想法。</p>
</blockquote>
<blockquote>
<p>“你挺容忍的。”她说，“但你心里还是有委屈。”这话说得我一怔。委屈，这个词，好像心里有一只捏紧的小拳头。</p>
</blockquote>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 使用 RSA 做加密</title>
    <url>/2018/09/25/Node-js-%E4%BD%BF%E7%94%A8-RSA-%E5%81%9A%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>RSA加密算法是一种非对称加密算法。</p>
<p>假设 A 与 B 通信。A 和 B 都提供一个公开的公钥。A 把需要传递的信息，先用自己的私钥签名，再用 B 的公钥加密。B 接收到这串密文后，用自己的私钥解密，用 A 提供的公钥验签。</p>
<p>为什么要先签名后加密？如果你先加密后签名，非法用户通过获取的公钥就可以破解签名，破解之后就可以替换签名。</p>
<p>详细的原理可以参考以下文档：<br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA算法原理（一）</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA算法原理（二）</a></p>
<h2 id="node-rsa"><a href="#node-rsa" class="headerlink" title="node-rsa"></a>node-rsa</h2><p>在 node.js 中使用 rsa 算法，我们使用的是 <a href="https://github.com/rzcoder/node-rsa" target="_blank" rel="noopener">node-rsa</a> 这个包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeRSA = <span class="built_in">require</span>(<span class="string">'node-rsa'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a_public_key_data = <span class="string">'-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----'</span>;</span><br><span class="line"><span class="keyword">const</span> a_private_key_data = <span class="string">'-----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY-----'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b_public_key_data = <span class="string">'-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----'</span>;</span><br><span class="line"><span class="keyword">const</span> b_private_key_data = <span class="string">'-----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY-----'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 A 的公私钥对象</span></span><br><span class="line"><span class="keyword">const</span> a_public_key = <span class="keyword">new</span> NodeRSA(a_public_key_data);</span><br><span class="line"><span class="keyword">const</span> a_private_key = <span class="keyword">new</span> NodeRSA(a_private_key_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 B 的公私钥对象</span></span><br><span class="line"><span class="keyword">const</span> a_public_key = <span class="keyword">new</span> NodeRSA(a_public_key_data);</span><br><span class="line"><span class="keyword">const</span> a_private_key = <span class="keyword">new</span> NodeRSA(a_private_key_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">'Hello RSA!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加签并加密</span></span><br><span class="line"><span class="keyword">const</span> sign = a_private_key.sign(text, <span class="string">'base64'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'A 私钥加签:'</span>, sign);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encrypted = a_public_key.encrypt(sign, <span class="string">'base64'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'B 公钥加密:'</span>, encrypted);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密并验签</span></span><br><span class="line"><span class="keyword">const</span> decrypted = a_public_key.decrypt(encrypted, <span class="string">'utf8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'B 私钥解密:'</span>, decrypted);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> verify = a_public_key.verify(text, decrypted, <span class="string">'utf8'</span>, <span class="string">'base64'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'A 公钥验签:'</span>, verify);</span><br></pre></td></tr></table></figure>
<h2 id="serialize"><a href="#serialize" class="headerlink" title="serialize"></a>serialize</h2><a id="more"></a>
<p>接口传递的一般是复杂的对象，所以我们需要把对象按一定的顺序排列并序列化成字符串再进行签名加密的操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> serialize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> str = [];</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).sort().forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      str.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(obj[key]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> str.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>RSA 算法有一定的计算量，加上 Node 不适合做计算密集型的操作。当接口被频繁调用可能会占用主线程，阻塞其他接口，使用了 RSA 的接口并发量会下降十倍左右。如非必要，谨慎在 Node 里使用 RSA。</p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>JavaScript</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>用node.js写一个jenkins发版脚本</title>
    <url>/2018/09/25/%E7%94%A8node-js%E5%86%99%E4%B8%80%E4%B8%AAjenkins%E5%8F%91%E7%89%88%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>每次到网页里手动发版有点烦，写个脚本来提高开发效率。</p>
<a id="more"></a>
<h2 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h2><p>在 jenkins 设置里获取 <code>API TOKEN</code>。<br>把 host 和账号密码拼接起来就可以通过鉴权。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> token = &#123;</span><br><span class="line">  user: <span class="string">''</span>,</span><br><span class="line">  password: <span class="string">''</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">'jenkins.xxx.cn'</span>;</span><br><span class="line"><span class="keyword">const</span> basicUrl = <span class="string">`http://<span class="subst">$&#123;token.user&#125;</span>:<span class="subst">$&#123;token.password&#125;</span>@<span class="subst">$&#123;host&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<h2 id="BUILD"><a href="#BUILD" class="headerlink" title="BUILD"></a>BUILD</h2><!-- more -->
<p>调用 jenkins 提供的 <code>jenkins.job.build()</code> 方法发版。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// crumbIssuer 默认false, true 启用CSRF保护支持</span></span><br><span class="line"><span class="keyword">const</span> jenkins = <span class="built_in">require</span>(<span class="string">'jenkins'</span>)(&#123; baseUrl, <span class="attr">crumbIssuer</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> job_name = <span class="string">''</span>;  <span class="comment">// 想要发版的job的名字</span></span><br><span class="line"></span><br><span class="line">jenkins.job.build(</span><br><span class="line">  &#123;</span><br><span class="line">    name: job_name,</span><br><span class="line">    parameters: &#123;</span><br><span class="line">      name: <span class="string">'value'</span>,  <span class="comment">// 填写一些参数信息</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'queue item number'</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="查看发版状态"><a href="#查看发版状态" class="headerlink" title="查看发版状态"></a>查看发版状态</h2><p>执行 build 之后我们想要查看当前 build 的状态，只成功、失败还是进行中。</p>
<p><code>jenkins.job.get()</code> 获取当前 job 的信息。<code>data.lastBuild.number</code> 可以拿到最后一个 build 的 number，最后一个 build 也就是我们刚刚触发的 build。<br><code>jenkins.build.get()</code> 获取当前 build 的信息。<code>data.result</code> 获取当前 build 的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jenkins.job.get(job_name, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lastBuildNumber = data.lastBuild.number;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'last build number'</span>, lastBuildNumber);</span><br><span class="line"></span><br><span class="line">  jenkins.build.get(job_name, lastBuildNumber, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'last build result'</span>, data.result);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://www.npmjs.com/package/jenkins" target="_blank" rel="noopener">jenkins</a></p>
]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>JavaScript</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛视频切片方案</title>
    <url>/2018/08/07/%E4%B8%83%E7%89%9B%E8%A7%86%E9%A2%91%E5%88%87%E7%89%87%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>使用七牛 sdk 上传视频并做分片操作。</p>
<h3 id="step1-生成-token"><a href="#step1-生成-token" class="headerlink" title="step1 生成 token"></a>step1 生成 token</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qiniu = <span class="built_in">require</span>(<span class="string">"qiniu"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> accessKey = proc.env.QINIU_ACCESS_KEY;</span><br><span class="line"><span class="keyword">var</span> secretKey = proc.env.QINIU_SECRET_KEY;</span><br><span class="line"><span class="keyword">var</span> mac = <span class="keyword">new</span> qiniu.auth.digest.Mac(accessKey, secretKey);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bucket = proc.env.QINIU_TEST_BUCKET;  <span class="comment">// 对象存储空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带数据处理的凭证</span></span><br><span class="line"><span class="keyword">var</span> origin_filename = <span class="string">"avthumb_test_target.mp4"</span>;  <span class="comment">// 源文件名</span></span><br><span class="line"><span class="keyword">var</span> save_as_filename = <span class="string">`<span class="subst">$&#123;origin_filename&#125;</span>.m3n8`</span>;  <span class="comment">// 分片后的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> saveMp4Entry = qiniu.util.urlsafeBase64Encode(<span class="string">`<span class="subst">$&#123;bucket&#125;</span>:<span class="subst">$&#123;save_as_filename&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">var</span> avthumbMp4Fop = <span class="string">"avthumb/m3u8/noDomain/1/segtime/15/vb/440k|saveas/"</span> + saveMp4Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  scope: bucket,</span><br><span class="line">  expires: <span class="number">3600</span>,  <span class="comment">// 凭证有效时间</span></span><br><span class="line">  persistentOps: avthumbMp4Fop,  <span class="comment">// 视频上传后触发预转持久化，切片处理</span></span><br><span class="line">  persistentPipeline: <span class="string">"video-pipe"</span>,  <span class="comment">// 多媒体处理队列</span></span><br><span class="line">  persistentNotifyUrl: <span class="string">"http://api.example.com/qiniu/pfop/notify"</span>,  <span class="comment">// 回调通知地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> putPolicy = <span class="keyword">new</span> qiniu.rs.PutPolicy(options);</span><br><span class="line"><span class="built_in">console</span>.log(putPolicy.uploadToken(mac));</span><br></pre></td></tr></table></figure>
<p>生成不同作用的凭证可以查看官方提供的示例<a href="https://github.com/qiniu/nodejs-sdk/blob/master/examples/create_uptoken.js" target="_blank" rel="noopener">nodejs-sdk example</a>。</p>
<p>以上代码为生成上传视频并进行切片处理的凭证。上传相关的文档查看<a href="https://developer.qiniu.com/kodo/manual/1206/put-policy" target="_blank" rel="noopener">七牛上传策略</a>。</p>
<p>切片动作是由<code>persistentOps</code>参数触发并启动一个异步任务，</p>
<h2 id="persistentOps-详解"><a href="#persistentOps-详解" class="headerlink" title="persistentOps 详解"></a><strong>persistentOps 详解</strong></h2><a id="more"></a>
<blockquote>
<p><code>persistentOps</code> 字段用于指定预转数据处理命令和保存处理结果的存储空间与资源名。<br>为此字段指定非空值，则在成功上传一个文件后，会启动一个<strong>异步数据处理任务</strong>。<code>persistentId</code> 字段，唯一标识此任务。<br>当 <code>returnBody</code> 中指定了 <code>persistentId</code> 魔法变量时，客户端收到的响应内容 <code>returnBody</code> 中会有 <code>persistentId</code>；当没有指定 <code>returnBody</code> 时，默认也会返回 <code>persistentId</code>。</p>
<ul>
<li>使用默认的存储空间和资源名<pre><code>* 当只指定了数据处理命令时，服务端会选择上传文件的 Bucket 作为数据处理结果的存储空间，Key 由七牛服务器自动生成。
</code></pre></li>
<li><strong>使用指定的存储空间和资源名</strong><ul>
<li>在数据处理命令后用管道符<code>|</code>拼接<code>saveas/&lt;encodedEntryURI&gt;</code>指令，指示七牛服务器使用<a href="https://developer.qiniu.com/kodo/api/data-format" target="_blank" rel="noopener">EncodedEntryURI</a>格式中指定的 Bucket 与 Key 来保存处理结果。如 <em>avthumb/flv|saveas/cWJ1Y2tldDpxa2V5</em>，是将上传的视频文件转码<code>flv</code>格式后存储为<code>qbucket:qkey</code>，其中<code>cWJ1Y2tldDpxa2V5</code>是<code>qbucket:qkey</code>的<a href="https://developer.qiniu.com/kodo/manual/appendix#urlsafe-base64" target="_blank" rel="noopener">URL安全的Base64编码</a>结果。以上方式可以同时作用于多个数据处理命令，用<code>;</code>分隔，如 <code>avthumb/mp4|saveas/cWJ1Y2tldDpxa2V5;avthumb/flv|saveas/cWJ1Y2tldDpxa2V5Mg==</code></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>摘自<a href="https://developer.qiniu.com/kodo/manual/1208/upload-token" target="_blank" rel="noopener">七牛上传凭证</a></p>
</blockquote>
<p>数据处理命令可以查看官方文档，比如<a href="https://developer.qiniu.com/dora/manual/1485/audio-and-video-slice" target="_blank" rel="noopener">视频切片接口</a>。</p>
<h3 id="step2-前端直传"><a href="#step2-前端直传" class="headerlink" title="step2 前端直传"></a>step2 前端直传</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">POST http:<span class="comment">//up.qiniu.com</span></span><br><span class="line">格式： form-data</span><br><span class="line">参数：</span><br><span class="line">key: 文件名，上文代码中的 <span class="string">`origin_filename`</span></span><br><span class="line">token: 上传token</span><br><span class="line">file: 具体文件</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传成功的响应体</span></span><br><span class="line"><span class="comment">// 状态码 200</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"hash"</span>: <span class="string">"luVJbz9RtE3Ha7c9XaDerE6rPyvP"</span>,</span><br><span class="line">    <span class="string">"key"</span>: <span class="string">"prTEDwvJY18YBD_720_p1.mp4"</span>,</span><br><span class="line">    <span class="string">"persistentId"</span>: <span class="string">"z0.5b56c9b938b9f324a573edb4"</span> <span class="comment">// 可以使用persistentId，检测当前处理状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：youthcity</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/f73b39ae02dc</span></span><br><span class="line">來源：简书</span><br><span class="line">简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</span><br></pre></td></tr></table></figure>
<h3 id="step3-轮询获取结果"><a href="#step3-轮询获取结果" class="headerlink" title="step3 轮询获取结果"></a>step3 轮询获取结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET api.qiniu.com/status/<span class="keyword">get</span>/prefop?id=$&#123;persistentId&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">0</span>, <span class="comment">//   状态码0成功，1等待处理，2正在处理，3处理失败，4通知提交失败。</span></span><br><span class="line">    <span class="string">"desc"</span>: <span class="string">"The fop was completed successfully"</span>,</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"z0.5b56c9b938b9f324a573edb4"</span>,</span><br><span class="line">    <span class="string">"inputBucket"</span>: <span class="string">"ocean"</span>,</span><br><span class="line">    <span class="string">"inputKey"</span>: <span class="string">"prTEDwvJY18YBD_720_p1.mp4"</span>,</span><br><span class="line">    <span class="string">"items"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"cmd"</span>: <span class="string">"avthumb/m3u8/noDomain/1/segtime/15/vb/440k|saveas/b2NlYW46aGxzX3ByVEVEd3ZKWTE4WUJEXzcyMF9wMS5tM3U4"</span>,</span><br><span class="line">            <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"desc"</span>: <span class="string">"The fop was completed successfully"</span>,</span><br><span class="line">            <span class="string">"hash"</span>: <span class="string">"FraV6PX6Xp7mYYgAnY0sniTK-pPt"</span>,</span><br><span class="line">            <span class="string">"key"</span>: <span class="string">"hls_prTEDwvJY18YBD_720_p1.m3u8"</span>,</span><br><span class="line">            <span class="string">"returnOld"</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"pipeline"</span>: <span class="string">"1381326751.k12_video"</span>,</span><br><span class="line">    <span class="string">"reqid"</span>: <span class="string">"FQIAAKAxpZfFOkQV"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：youthcity</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/f73b39ae02dc</span></span><br><span class="line">來源：简书</span><br><span class="line">简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.qiniu.com/kodo/manual/1208/upload-token" target="_blank" rel="noopener">七牛上传凭证</a></p>
<p><a href="https://developer.qiniu.com/kodo/manual/1206/put-policy" target="_blank" rel="noopener">七牛上传策略</a></p>
<p><a href="https://developer.qiniu.com/dora/manual/1485/audio-and-video-slice" target="_blank" rel="noopener">视频切片接口</a></p>
<p><a href="https://www.jianshu.com/p/f73b39ae02dc" target="_blank" rel="noopener">七牛上传开发（三）使用NodeJS生成带数据处理的凭证</a></p>
<p><a href="https://github.com/qiniu/nodejs-sdk/blob/master/examples/create_uptoken.js" target="_blank" rel="noopener">nodejs-sdk example</a></p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>JavaScript</tag>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title>Sequelize 基本操作</title>
    <url>/2018/01/10/Sequelize-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="sequelize-基本操作"><a href="#sequelize-基本操作" class="headerlink" title="sequelize 基本操作"></a>sequelize 基本操作</h1><p><a href="http://docs.sequelizejs.com/" target="_blank" rel="noopener">Sequelize</a> 是 Node 的一个 ORM(Object-Relational Mapping) 框架，用来方便数据库操作。</p>
<h2 id="配置-sequelize"><a href="#配置-sequelize" class="headerlink" title="配置 sequelize"></a>配置 sequelize</h2><blockquote>
<p>以 mysql 为例</p>
</blockquote>
<p>首先我们要引入npm包，sequelize 依赖 mysql2 作为底层驱动，暴露出自己的 API 让我们调用，在转成 mysql 语句进行执行。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"mysql2": "^1.5.1",</span><br><span class="line">"sequelize": "^4.28.6"</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">'sequelize'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">'database'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>, &#123;</span><br><span class="line">  host: sqlconf.host,</span><br><span class="line">  dialect: <span class="string">'mysql'</span>, <span class="comment">// 这里可以改成任意一种关系型数据库</span></span><br><span class="line"></span><br><span class="line">  pool: &#123;</span><br><span class="line">    max: <span class="number">5</span>,</span><br><span class="line">    min: <span class="number">0</span>,</span><br><span class="line">    acquire: <span class="number">30000</span>,</span><br><span class="line">    idle: <span class="number">10000</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试连接是否成功</span></span><br><span class="line">sequelize</span><br><span class="line">  .authenticate()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection has been established successfully.'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Unable to connect to the database'</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 model自动创建表</span></span><br><span class="line">sequelize</span><br><span class="line">  .sync()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init db ok'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init db error'</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>我们可以调用<code>sync()</code>根据 model自动在数据库中创建表，也可以不调用，自己手动创。如果使用了 Sequelize 的 <a href="http://docs.sequelizejs.com/manual/tutorial/associations.html" target="_blank" rel="noopener">Associations</a>，这必须通过 <code>sync()</code> 生成表结构。</p>
<h2 id="创建-model"><a href="#创建-model" class="headerlink" title="创建 model"></a>创建 model</h2><p>创建模型，告诉 Sequelize 如何映射数据库表</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UserModel = sequelize.define(<span class="string">'user'</span>, &#123;</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: Sequelize.INTEGER(<span class="number">11</span>),</span><br><span class="line">    primaryKey: <span class="literal">true</span>,            <span class="comment">// 主键</span></span><br><span class="line">    autoIncrement: <span class="literal">true</span>,         <span class="comment">// 自动递增</span></span><br><span class="line">  &#125;,</span><br><span class="line">  username: Sequelize.STRING(<span class="number">100</span>),</span><br><span class="line">  password: Sequelize.STRING(<span class="number">100</span>),</span><br><span class="line">  createdAt: Sequelize.BIGINT,</span><br><span class="line">  updatedAt: Sequelize.BIGINT,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  timestamps: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>define()</code> 方法的第一个参数为表名，对应的是 <strong>users</strong> 表。如果不设置 timestamps，Sequlize 会自动为我们添加创建时间和更新时间，我一般选择关闭，手动添加灵活性高些。</p>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> UserModel.create(&#123;</span><br><span class="line">    username: <span class="string">'小张'</span>,</span><br><span class="line">    password: <span class="string">'root'</span>,</span><br><span class="line">    createAt: now,</span><br><span class="line">    updateAt: now,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'创建：'</span> + <span class="built_in">JSON</span>.stringify(user))</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 查找所有</span></span><br><span class="line">  <span class="keyword">const</span> allUser = <span class="keyword">await</span> UserModel.findAll()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按id查找</span></span><br><span class="line">  <span class="keyword">const</span> oneUser = <span class="keyword">await</span> UserModel.findById(id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按条件查询</span></span><br><span class="line">  <span class="keyword">const</span> someUser = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">    where: &#123;</span><br><span class="line">      <span class="comment">// 模糊查询</span></span><br><span class="line">      name: &#123;</span><br><span class="line">        $like: <span class="string">'%小%'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 精确查询</span></span><br><span class="line">      password: <span class="string">'root'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分页查询</span></span><br><span class="line">  <span class="keyword">const</span> size = <span class="number">10</span> <span class="comment">// 每页10条数据</span></span><br><span class="line">  <span class="keyword">const</span> page = <span class="number">1</span> <span class="comment">// 页数</span></span><br><span class="line">  <span class="keyword">const</span> pageUser = <span class="keyword">await</span> UserModel.findAndCountAll(&#123;</span><br><span class="line">    where: &#123;</span><br><span class="line">      name: &#123;</span><br><span class="line">        $like: <span class="string">'%小%'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    limit: size,</span><br><span class="line">    offset: size * (page - <span class="number">1</span>),</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">await</span> UserModel.upert(data)  <span class="comment">// data 里面如果带有 id 则更新，不带则新建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> UserModel.findById(id)</span><br><span class="line">user.update(data)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="comment">// 删除所有名字带’小‘的用户</span></span><br><span class="line"><span class="keyword">await</span> UserModel.destroy(&#123;</span><br><span class="line">  where: &#123;</span><br><span class="line">    username: <span class="string">'小'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> UserModel.findById(id)</span><br><span class="line">user.destroy()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="关联表"><a href="#关联表" class="headerlink" title="关联表"></a>关联表</h2><p>Sequelize 提供了一对一，一对多，多对多等关联表操作，我用的不多，这里只介绍 <code>hasMany()</code> 这一种，其他的可以看<a href="http://docs.sequelizejs.com/manual/tutorial/associations.html" target="_blank" rel="noopener">文档</a>。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>首先要在 model 中设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> School = sequelize.define(<span class="string">'school'</span>, &#123;</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: Sequelize.INTEGER(<span class="number">11</span>),</span><br><span class="line">    primaryKey: <span class="literal">true</span>,</span><br><span class="line">    autoIncrement: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  username: Sequelize.STRING(<span class="number">100</span>),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Student = sequelize.define(<span class="string">'student'</span>, &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">    type: Sequelize.INTEGER(<span class="number">11</span>),</span><br><span class="line">    primaryKey: <span class="literal">true</span>,</span><br><span class="line">    autoIncrement: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  username: Sequelize.STRING(<span class="number">100</span>),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">School.hasMany(Student, &#123;<span class="attr">as</span>: <span class="string">'student'</span>, <span class="attr">foreignKey</span>: <span class="string">'schoolId'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>as 参数重新定义了目标model的名字。foreignKey 参数定义了在 t_student 表中关联 key 的名字。</p>
<h3 id="关联查"><a href="#关联查" class="headerlink" title="关联查"></a>关联查</h3><p>如果我们想查找一个学校和这个学校中所有的学生信息，可以这样找：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> group = <span class="keyword">await</span> School.findById(id, &#123;</span><br><span class="line">    include: [&#123;</span><br><span class="line">      model: Student,</span><br><span class="line">      <span class="keyword">as</span>: <span class="string">'student'</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>如果我们设置了 as 就需要在 include 选项中设置同样的 as。</p>
<p>按条件查找</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> group = <span class="keyword">await</span> School.findAll(&#123;</span><br><span class="line">    where: &#123;</span><br><span class="line">      name: <span class="string">'someting'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    include: [&#123;</span><br><span class="line">      model: Student,</span><br><span class="line">      <span class="keyword">as</span>: <span class="string">'student'</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>更多详细操作请参考<a href="http://docs.sequelizejs.com/" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 iPhone 微信 H5 无法自动播放音乐问题</title>
    <url>/2017/11/29/%E8%A7%A3%E5%86%B3-iPhone-%E5%BE%AE%E4%BF%A1-H5-%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>使用 wx sdk 在html导入sdk js文件。（<strong>如果网站是https导入的sdk也要使用https！</strong>）<br>然后在 <code>wx.ready</code> 中设置 play 方法并复制给全局变量 fm，当需要使用的时候再调用 fm()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量 fm2</span></span><br><span class="line"><span class="keyword">var</span> fm2;</span><br><span class="line"></span><br><span class="line">wx.config(&#123;</span><br><span class="line">  debug : <span class="literal">false</span>, <span class="comment">// 这里为false</span></span><br><span class="line">  appId : <span class="string">''</span>, <span class="comment">// 以下随意填写即可</span></span><br><span class="line">  timestamp : (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime(),</span><br><span class="line">  nonceStr : <span class="string">''</span>,</span><br><span class="line">  signature : <span class="string">''</span>,</span><br><span class="line">  jsApiList : [<span class="string">'checkJsApi'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#music1'</span>).play();  <span class="comment">// 第一段音乐页面加载后自动播放</span></span><br><span class="line">  $(<span class="string">'#music2'</span>).load();  <span class="comment">// 第二段音乐等待，触发 fm2 时播放</span></span><br><span class="line"></span><br><span class="line">  fm2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    music2.play();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fm2(); <span class="comment">//调用之后即可播放</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>promise 和 async 的用法</title>
    <url>/2017/10/27/promise-%E5%92%8C-async-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先构造一个 promise 函数</span></span><br><span class="line"><span class="comment">// resolve 和 reject 都是一个函数</span></span><br><span class="line"><span class="comment">// resolve 在成功时调用</span></span><br><span class="line"><span class="comment">// reject 在失败时调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tar = <span class="built_in">Math</span>.random(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (tar &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'suceess'</span>)</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">'resolve'</span>)  </span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fail'</span>)</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="string">'reject'</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then 和 catch 第一个参数为resolve状态时的回调，第二个参数为reject状态时的回调</span></span><br><span class="line"><span class="comment">// catch 相当于 then(null, reject)</span></span><br><span class="line">promise().then(</span><br><span class="line">  (resolve) =&gt; <span class="built_in">console</span>.log(<span class="string">'then'</span>, resolve)</span><br><span class="line">).catch(</span><br><span class="line">  (reject) =&gt; <span class="built_in">console</span>.log(<span class="string">'catch'</span>, reject)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// then 后面还可以接 then 一直链式调用</span></span><br><span class="line"><span class="comment">// 第一个 then 接受的参数是 resolve 函数传过来的参数</span></span><br><span class="line"><span class="comment">// 第二个 then 接受一个参数是第一个 then 返回的值</span></span><br><span class="line">promise().then(</span><br><span class="line">  (resolve) =&gt; (resolve + <span class="number">1</span>)  <span class="comment">// 接受 resolve 返回 resolve + 1</span></span><br><span class="line">).then(</span><br><span class="line">  (plusOne) =&gt; <span class="built_in">console</span>.log(plusOne)  <span class="comment">// 接受 resolve +1 并打印</span></span><br><span class="line">).catch(</span><br><span class="line">  (reject) =&gt; <span class="built_in">console</span>.log(<span class="string">'catch'</span>, reject)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同样需要一个 promise 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tar = <span class="built_in">Math</span>.random(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (tar &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">'resolve'</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fail'</span>)</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        reject(<span class="string">'reject'</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是调用的方法跟 then/catch 不一样</span></span><br><span class="line"><span class="comment">// async 函数执行时，一旦遇到 await 就会先返回，等异步操作完成，再接着执行后面的操作</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> promise()</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wait'</span>)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async 函数返回 promise 对象</span></span><br><span class="line"><span class="comment">// 只有函数内的 await 语句全部执行完，或者遇到 return 或 抛出错误，才会发生状态改变</span></span><br><span class="line"><span class="comment">// 如果发生错误或状态为 reject 则执行 catch</span></span><br><span class="line"><span class="keyword">async</span>().then(</span><br><span class="line">  (res) =&gt; <span class="built_in">console</span>.log(res)</span><br><span class="line">).catch(</span><br><span class="line">  (e) =&gt; <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云云服务器的端口配置问题</title>
    <url>/2017/05/23/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>心血来潮花了9块9（学生价）买了个阿里云。因为后端只会一点 Node，所以上来第一件事就是按照<a href="https://help.aliyun.com/document_detail/50775.html?spm=5176.doc52806.6.661.QHbNL5" target="_blank" rel="noopener">官方教程</a>把部署 Node 项目这个教程撸了一遍。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><h4 id="官方教程代码"><a href="#官方教程代码" class="headerlink" title="官方教程代码"></a>官方教程代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'ECS公网IP地址'</span>;  <span class="comment">// 这里把文字换成自己的公网IP地址</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(port, hostname, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一段简单最简单的 Node http服务器，成功运行后可以在页面输出 Hello World。</p>
<a id="more"></a>
<h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p><img data-src="http://omwf3ob75.bkt.clouddn.com/%E6%8A%A5%E9%94%99.png" alt="报错"></p>
<p>报错了，因为之前写node只需要监听端口，没必要把IP地址也给写进去，所以我删了hostname，改成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'ECS公网IP地址'</span>;  <span class="comment">// 这里把文字换成自己的公网IP地址</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span>;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(port, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行成功，但是在外网用浏览器输入IP地址之后无法访问。</p>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p><code>curl ip.cn</code> </p>
<p>查询当前外网IP，没有问题，与阿里云提供的一致。</p>
<p><code>ping www.baidu.com</code></p>
<p>服务器可以访问外网</p>
<p><code>curl http://127.0.0.1:3000</code></p>
<p>正确输出 “Hello World”，说明代码的编写没有问题。</p>
<p>代码没问题，服务器网络没问题，ip地址没问题。我估计应该是防火墙把端口禁掉了。</p>
<h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><p>身为小菜鸟，第一时间想到的就是把服务器的防火墙关掉。我的服务器是 CentOS7.0 ，与6.0不一样，CentOS7.0默认使用 <code>firewall</code> 作为防火墙。</p>
<p><code>systemctl stop firewalld.service</code>       #停止firewall</p>
<p><code>systemctl disable firewalld.service</code>    #禁止开机启动firewall</p>
<p><code>firewall-cmd --state</code>                   #查看防火墙状态，已经处于关闭状态</p>
<p>开Node服务器，浏览器访问还是失败。</p>
<p>好像没招了，问小伙伴，他们说可能是没有备案的原因。但是没备案的小伙伴说他用得好好的，而且我就买了一个月的服务器，再等半个月备案我也不需要用了。正打算放弃问客服，小伙伴说你装个Nginx试试，只要正确运行Nginx而且服务器没问题直接访问IP地址就能出现Nginx首页了。</p>
<h4 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h4><p>CentOS有两种方法安装Nginx，具体的自行谷歌吧。</p>
<p>安装完成，运行成功。</p>
<p>浏览器访问公网IP，无法访问。</p>
<p>从吃完中午饭13:00一直折腾到下午6:30左右，一动不动坐凳子上5个多小时了，不行了，休息吃完饭去。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>既然Nginx正确运行，那只剩两个问题了，一个是没有备案，不过这个问题的可能性很小很小。还有一点就是虽然我CentOS上把防火墙关了，但云服务器上阿里云应该会有一些安全措施，导致一部分端口被禁，或者压根就没有把端口打开。</p>
<p>吃完饭，散完步，我就在云服务器控制台里一个一个的找，发现安全组里点击配置规则后有一个安全组规则，里面通过添加安全组规则可以开放需要用到的端口。默认只打开了两个端口。</p>
<p><img data-src="http://omwf3ob75.bkt.clouddn.com/%E5%AE%89%E5%85%A8%E7%BB%841.png" alt="安全组"><br><img data-src="http://omwf3ob75.bkt.clouddn.com/%E5%AE%89%E5%85%A8%E7%BB%842.png" alt="安全组"><br><img data-src="http://omwf3ob75.bkt.clouddn.com/%E5%AE%89%E5%85%A8%E7%BB%843.png" alt="安全组"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是一个简单的问题，不过需要一步步排除掉可能的原因。</p>
<p>如果身边有个后端或者运维的小伙伴在的话，应该可以很快意识到这个问题。独狼是走不远的，至少是走不快的。</p>
<p>其实在购买时就可以选取要开放的端口，第一次嘛，没有经验，都是直接默认选项。怪不得小伙伴说他服务器的配置都没有动过，应该是购买的时候就已经设置好的。</p>
<p>趁年轻，多踩坑。</p>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>《图解HTTP》读书笔记</title>
    <url>/2017/04/23/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h1><p>TCP/IP 协议族按层次分为以下4层：应用层、传输层、网络层和数据链路层。</p>
<p>应用层决定了向用户提供应用服务时通信的活动。DNS服务、HTTP协议处于该层。</p>
<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP协议处于该层。</p>
<p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方的计算机，并把数据包传给对方。IP网际协议位于该层。</p>
<p>链路层用来处理链接网络的硬件部分。包括操作系统、硬件驱动等。</p>
<a id="more"></a>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP网际协议位于网络层。IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。</p>
<p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。</p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP协议位于传输层，提供可靠的字节流服务。</p>
<p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。</p>
<h3 id="三次握手（three-way-handshaking）"><a href="#三次握手（three-way-handshaking）" class="headerlink" title="三次握手（three-way handshaking）"></a>三次握手（three-way handshaking）</h3><p>为了准确无误地将数据送达目标处，TCP协议采用了三次握手策略。</p>
<p>发送端发送一个带SYN标志的数据包给对方 –&gt; 接受端收到后传回一个带SYN/ACK标志的数据包以示传达确认信息 –&gt; 发送端再传回一个带ACK标志的数据包表示握手结束</p>
<h2 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h2><p>DNS服务位于应用层。提供域名到IP地址之间的解析服务。</p>
<h2 id="整个服务的流程"><a href="#整个服务的流程" class="headerlink" title="整个服务的流程"></a>整个服务的流程</h2><p>客户端请求一个网址 –&gt; DNS把域名解析为IP地址 –&gt; HTTP生成针对目标Web服务器的HTTP请求报文 –&gt; TCP将HTTP请求报文分割成报文段按序号传输 –&gt; IP协议负责搜索对方的地址边中转边传送 –&gt; TCP从对方那里接受报文段并重组成报文 –&gt; HTTP对请求的内容进行处理 –&gt; 请求的处理结果也按照这个流程返回客户端</p>
<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取资源</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>一般用于提交需要存储的信息</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取报文首部</td>
<td>和GET一样，只是不返回报文主体部分</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
</tr>
</tbody>
</table>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>在HTTP/1.1中，所有的连接默认都是持久连接</p>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
</tr>
</thead>
<tbody>
<tr>
<td>2**</td>
<td>成功</td>
</tr>
<tr>
<td>3**</td>
<td>重定向</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5**</td>
<td>服务端错误</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>阅读</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>一个 Vue + Node + MongoDB 博客系统</title>
    <url>/2017/04/22/%E4%B8%80%E4%B8%AA-Vue-Node-MongoDB-%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><img data-src="http://cdn.chaohang.top/20200812110436.jpg" alt=""></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a><a href="https://github.com/chaohangz/vueBlog" target="_blank" rel="noopener">源码</a></h1><p>耗时半载（半个月）的大项目终于完成了。这是一个博客系统，使用 Vue 做前端框架，Node + express 做后端，数据库使用的是 MongoDB。实现了用户注册、用户登录、博客管理（文章的修改和删除）、文章编辑（Markdown）、标签分类等功能。</p>
<a id="more"></a>
<p>很早之前就想写一个个人博客。学了 Vue 之后，把前端部分写出来，然后 Node 一直拖拖拉拉的学了很久，中间又跑去实习了一段时间，所以直到回学校之后才列了个计划把这个项目实现了。</p>
<p>翻出之前写的前端部分，好丑啊，干脆推掉重写吧。前端模仿的是 hexo 的经典主题 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a> ，本来是想把源码直接拿过来用的，后来发现还不如自己写来得快，就全部自己动手实现成 vue components。</p>
<h2 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h2><ol>
<li>文章的编辑，修改，删除</li>
<li>支持使用 <code>Markdown</code> 编辑与实时预览</li>
<li>支持代码高亮</li>
<li>给文章添加标签</li>
<li>支持用户注册登录</li>
</ol>
<h2 id="使用到的技术"><a href="#使用到的技术" class="headerlink" title="使用到的技术"></a>使用到的技术</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ol>
<li>Vue.js</li>
<li>vue-cli</li>
<li>vue-router</li>
<li>vue-resource</li>
<li>element-ui</li>
<li>marked</li>
<li>highlight.js</li>
</ol>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol>
<li>Node.js</li>
<li>Express</li>
<li>Mongoose</li>
</ol>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>前端使用 <code>vue-router</code> 操作路由，实现单页应用的效果。使用 <code>vue-resource</code> 从后台获取数据，数据的处理全部都在前端，所以后端要做的事情很简单——把前端打包好的数据存进数据库中和从数据库中取出数据。前后端使用统一的路由命名规则。</p>
<h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| app.js              后端入口</span><br><span class="line">| index.html          入口页面</span><br><span class="line">| .babelrc            babel配置</span><br><span class="line">| .gitignore          git配置</span><br><span class="line">| package.json</span><br><span class="line">| webpack.config.js   webpack配置</span><br><span class="line">|</span><br><span class="line">|-dist                vue打包生成的文件</span><br><span class="line">|</span><br><span class="line">|-node_modules        模块</span><br><span class="line">|</span><br><span class="line">|-server              后端</span><br><span class="line">    | check.js</span><br><span class="line">    | db.js           数据库</span><br><span class="line"> __| router.js       路由</span><br><span class="line">|</span><br><span class="line">|-src                 前端</span><br><span class="line">    |-assets          静态资源</span><br><span class="line">    |-components      组件</span><br><span class="line">    | App.vue</span><br><span class="line">    | main.js</span><br></pre></td></tr></table></figure>
<h2 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h2><p>webpack 大部分是 vue-cli 自动生成的，添加了让前后端http请求都转到node的3000端口，而不是前端的8080端口的配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让前后端http请求都转到node的3000端口，而不是前端的8080端口</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://localhost:3000/'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及一个新手可能会不明白的问题（我之前就捣鼓了半天）。</p>
<p>开发的时候要先打开数据库 MongoDB ,使用命令 <code>mongod</code>。</p>
<p>然后打开后端服务器 <code>node app</code>，后端监听 3000 端口。</p>
<p>最后打开前端开发模式 <code>npm run dev</code>，前端启动了一个 webpack 服务器，监听 8080 端口用于热刷新。通过配置把前端的http请求转到 3000 端口。</p>
<h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p>所有页面都用到的元素可以写在 <code>App.vue</code> 上面，也可以写成公共组件。我在 App.vue 中使用了<a href="https://router.vuejs.org/zh-cn/essentials/named-views.html" target="_blank" rel="noopener">命名视图</a>，因为 sidebar 这个组件有的页面需要有的不需要，不需要的时候就不用加载。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--App.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"black_line"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"sidebar"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>路由的配置写在 main.js 中，分为前台展示和后台管理。后台管理统一以 ‘/admin’ 开头。注册页和登录页写在一起了，上面有两个按钮“注册”和“登录”（我好懒-_-）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">components</span>: &#123;<span class="attr">default</span>: article, <span class="attr">sidebar</span>: sidebar&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/article'</span>, <span class="attr">components</span>: &#123;<span class="attr">default</span>: article, <span class="attr">sidebar</span>: sidebar&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">components</span>: &#123;<span class="attr">default</span>: about, <span class="attr">sidebar</span>: sidebar&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/articleDetail/:id'</span>, <span class="attr">components</span>: &#123;<span class="attr">default</span>: articleDetail, <span class="attr">sidebar</span>: sidebar&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/admin/articleList'</span>, <span class="attr">components</span>: &#123;<span class="attr">default</span>: articleList, <span class="attr">sidebar</span>: sidebar&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/admin/articleEdit'</span>, <span class="attr">component</span>: articleEdit&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/admin/articleEdit/:id'</span>, <span class="attr">component</span>: articleEdit&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/admin/signin'</span>, <span class="attr">component</span>: signin&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="element-UI"><a href="#element-UI" class="headerlink" title="element UI"></a>element UI</h3><p>使用了 element 用于消息提醒和标签分类。并不需要整个引入，而是使用按需引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// 按需引用element</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button, Message, MessageBox, Notification, Popover, Tag, Input &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-default/index.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = [Button, Message, MessageBox, Notification, Popover, Tag, Input]</span><br><span class="line"></span><br><span class="line">components.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  Vue.component(item.name, item)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MsgBox = MessageBox</span><br><span class="line">Vue.prototype.$msgbox = MsgBox</span><br><span class="line">Vue.prototype.$alert = MsgBox.alert</span><br><span class="line">Vue.prototype.$confirm = MsgBox.confirm</span><br><span class="line">Vue.prototype.$prompt = MsgBox.prompt</span><br><span class="line">Vue.prototype.$message = Message</span><br><span class="line">Vue.prototype.$notify = Notification</span><br></pre></td></tr></table></figure>
<h3 id="vue-resource"><a href="#vue-resource" class="headerlink" title="vue-resource"></a>vue-resource</h3><p>用于向后端发起请求。打通前后端的关键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET /someUrl</span></span><br><span class="line">  <span class="keyword">this</span>.$http.get(<span class="string">'/someUrl'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// success callback</span></span><br><span class="line">  &#125;, response =&gt; &#123;</span><br><span class="line">    <span class="comment">// error callback</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="get-请求"><a href="#get-请求" class="headerlink" title="get 请求"></a>get 请求</h4><p>前端发起 get 请求，当请求成功被返回执行第一个回调函数，请求没有被成功返回则执行第二个回调函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/api/articleDetail/'</span> + id).then(</span><br><span class="line">  response =&gt; <span class="keyword">this</span>.article = response.body,</span><br><span class="line">  response =&gt; <span class="built_in">console</span>.log(response)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>后端响应请求并返回结果<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line">router.get(<span class="string">'/api/articleDetail/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  db.Article.findOne(&#123; <span class="attr">_id</span>: req.params.id &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, docs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.send(docs)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h4><p>前端发起 post 请求，当请求成功被返回执行第一个回调函数，请求没有被成功返回则执行第二个回调函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建文章</span></span><br><span class="line"><span class="comment">// 即将被储存的数据 obj</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  title: <span class="keyword">this</span>.title,</span><br><span class="line">  date: <span class="keyword">this</span>.date,</span><br><span class="line">  content: <span class="keyword">this</span>.content,</span><br><span class="line">  gist: <span class="keyword">this</span>.gist,</span><br><span class="line">  labels: <span class="keyword">this</span>.labels</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.$http.post(<span class="string">'/api/admin/saveArticle'</span>, &#123;</span><br><span class="line">  articleInformation: obj</span><br><span class="line">&#125;).then(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">    self.$message(&#123;</span><br><span class="line">      message: <span class="string">'发表文章成功'</span>,</span><br><span class="line">      type: <span class="string">'success'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 保存成功后跳转至文章列表页</span></span><br><span class="line">    self.refreshArticleList()</span><br><span class="line">  &#125;,</span><br><span class="line">  response =&gt; <span class="built_in">console</span>.log(response)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>后端存储数据并返回结果<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="comment">// 文章保存</span></span><br><span class="line">router.post(<span class="string">'/api/admin/saveArticle'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> db.Article(req.body.articleInformation).save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).send()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h2><p>后端使用 express 构建了一个简单的服务器，几乎只用于操作数据库。</p>
<p>app.js 位于项目根目录，使用 <code>node app</code> 运行服务器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParse = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"><span class="keyword">const</span> MongoStore = <span class="built_in">require</span>(<span class="string">'connect-mongo'</span>)(session)</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'./server/router'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">file</span> =&gt;</span> path.resolve(__dirname, file)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/dist'</span>, express.static(resolve(<span class="string">'./dist'</span>)))</span><br><span class="line">app.use(bodyParse.json())</span><br><span class="line">app.use(bodyParse.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">app.use(router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// session</span></span><br><span class="line">app.set(<span class="string">'trust proxy'</span>, <span class="number">1</span>) <span class="comment">// trust first proxy</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: <span class="string">'blog'</span>,</span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">true</span>,</span><br><span class="line">  cookie: &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    maxAge: <span class="number">2592000000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  store: <span class="keyword">new</span> MongoStore(&#123;</span><br><span class="line">    url: <span class="string">'mongodb://localhost:27017/blog'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> html = fs.readFileSync(resolve(<span class="string">'./'</span> + <span class="string">'index.html'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">  res.send(html)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'访问地址为 localhost:3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>给自己挖了一个坑。因为登录之后需要保存用户状态，用来判断用户是否登录，如果登录则可以进入后台管理，如果没有登录则不能进入后台管理页面。之前写 node 的时候用的是 session 来保存，不过spa应用不同于前后端不分离的应用，我在前端对用户输入的账号密码进行了判断，如果成功则请求登录在后端保存 session。不过不知道出于什么原因，session 总是没办法赋值。因为我 node 学的也是半吊子，所以暂时放着，等我搞清楚了再来填坑。</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol>
<li>学一个新模块，新框架第一步就是阅读官方文档。</li>
<li>不要觉得读文档费时间，认真的读一遍官方文档比你瞎折腾来得有效率。</li>
<li>阅读与你项目相关的优秀项目的源码，学习别人如何组织代码。</li>
<li>自己的解决方案不一定是最优解，不过在找到最优解之前不妨自己先试试。</li>
<li>框架模块的使用都不难，套API的活每个人都能干，只是快与慢的差别。</li>
<li>尝试思考这个API是如何实现的。</li>
<li>了解了完整的web应用是如何运作的，包括服务器，数据库，前端是如何联系在一起的。</li>
</ol>
<blockquote>
<p>本文首发于我的个人博客 <a href="https://chaohang.top" target="_blank" rel="noopener">https://chaohang.top</a></p>
<p>作者<a href="https://chaohang.top" target="_blank" rel="noopener">张小超</a></p>
<p>转载请注明出处</p>
</blockquote>
]]></content>
      <tags>
        <tag>node.js</tag>
        <tag>mongodb</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB基本操作</title>
    <url>/2017/04/17/mongoDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><code>use DATABASE_NAME</code> 如果数据库不存在则创建，否则切换到指定数据库</p>
<p><code>db</code>查看当前数据库名</p>
<p><code>show dbs</code> 查看所有数据库</p>
<p><code>show tables</code> 查看集合</p>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p><code>db.dropDatabase()</code> 删除当前数据库</p>
<p><code>db.collection.drop()</code>  删除集合，collection为集合名，例<code>db.student.drop()</code></p>
<h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><p><code>db.COLLECTION_NAME.insert(document)</code><br>实例<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.col.insert(&#123;</span><br><span class="line">	title: <span class="string">'MongoDB教程'</span>,</span><br><span class="line">	tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'nosql'</span>],</span><br><span class="line">	url: <span class="string">'www.runoob.com'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<p>我们也可以把数据定义为变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span> = (&#123;  <span class="comment">// 记得这边有个括号</span></span><br><span class="line">	title: <span class="string">'MongoDB教程'</span>,</span><br><span class="line">	tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'nosql'</span>],</span><br><span class="line">	url: <span class="string">'www.runoob.com'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">db.col.insert(<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure>
<p>插入文档也可以使用    <code>db.col.save(document)</code> 命令，如果不指定 <code>_id</code> 字段save()方法类似<br>于 insert()。如果指定 <code>_id</code> 字段，则会更新该 <code>_id</code> 的数据。</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><h3 id="update-方法"><a href="#update-方法" class="headerlink" title="update()方法"></a>update()方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">	&lt;query&gt;,  &#x2F;&#x2F; 查询条件</span><br><span class="line">	&lt;update&gt;,  &#x2F;&#x2F;update的对象和一些更新的操作符</span><br><span class="line">	&#123;</span><br><span class="line">		upsert: &lt;boolean&gt;,  &#x2F;&#x2F; 可选</span><br><span class="line">		multi: &lt;boolean&gt;,   &#x2F;&#x2F; 可选</span><br><span class="line">		writeConcern: &lt;document&gt;  &#x2F;&#x2F; 可选，抛出异常的级别</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>例子<br><code>db.col.update({&#39;title&#39;:&#39;MongoDB 教程&#39;},{$set:{&#39;title&#39;:&#39;MongoDB&#39;}})</code></p>
<p>以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置multi参数为true</p>
<h3 id="save-方法"><a href="#save-方法" class="headerlink" title="save()方法"></a>save()方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.save(</span><br><span class="line">	&lt;document&gt;, &#x2F;&#x2F; 传入文档用来替换之前的文档</span><br><span class="line">	&#123;</span><br><span class="line">		writeConcern: &lt;document&gt;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.col.save(&#123;</span><br><span class="line">	&quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;),  &#x2F;&#x2F; id唯一</span><br><span class="line">    &quot;title&quot; : &quot;MongoDB&quot;,</span><br><span class="line">    &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,</span><br><span class="line">    &quot;by&quot; : &quot;Runoob&quot;,</span><br><span class="line">    &quot;url&quot; : &quot;http:&#x2F;&#x2F;www.runoob.com&quot;,</span><br><span class="line">    &quot;tags&quot; : [</span><br><span class="line">            &quot;mongodb&quot;,</span><br><span class="line">            &quot;NoSQL&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;likes&quot; : 110</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">	&lt;query&gt;,       &#x2F;&#x2F; 可选，删除的文档的条件</span><br><span class="line">	&#123;</span><br><span class="line">		justOne:&lt;boolean&gt;,   &#x2F;&#x2F; 可选，如果为true或1，则只删除一个文档</span><br><span class="line">		writeConcern: &lt;document&gt;  &#x2F;&#x2F; 可选，抛出异常级别</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>例子<br><code>db.col.remove({&#39;title&#39;:&#39;mongodb&#39;})</code></p>
<p><code>db.col.remove({})</code> 删除所有数据</p>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p><code>db.col.find()</code> 查看已插入的文档<br><code>db.col.find().pretty()</code>  输出好看的格式<br><code>db.col.findOne()</code> 只返回一个文档</p>
<h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>(&gt;) 大于 - $gt<br>(&lt;) 小于 - $lt<br>(&gt;=) 大于等于 - $gte<br>(&lt;= ) 小于等于 - $lte<br><code>db.col.find({&quot;likes&quot; : {$gt : 100}})</code> 查找likes大于100的数据</p>
<h3 id="AND条件"><a href="#AND条件" class="headerlink" title="AND条件"></a>AND条件</h3><p>传入多个键值然后逗号隔开<br><code>db.col.find({key1: value1, key2: value2}).pretty()</code></p>
<h3 id="OR条件"><a href="#OR条件" class="headerlink" title="OR条件"></a>OR条件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	[</span><br><span class="line">		&#123;key1: value1&#125;, &#123;key2: value2&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;).pretty()</span><br></pre></td></tr></table></figure>
<h2 id="type操作符"><a href="#type操作符" class="headerlink" title="$type操作符"></a>$type操作符</h2><table>
<thead>
<tr>
<th>类型</th>
<th>数字</th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>1</td>
</tr>
<tr>
<td>String</td>
<td>2</td>
</tr>
<tr>
<td>Object</td>
<td>3</td>
</tr>
<tr>
<td>Array</td>
<td>4</td>
</tr>
<tr>
<td>Binary data</td>
<td>5</td>
</tr>
<tr>
<td>Object id</td>
<td>7</td>
</tr>
<tr>
<td>Boolean</td>
<td>8</td>
</tr>
<tr>
<td>Date</td>
<td>9</td>
</tr>
<tr>
<td>Null</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>不全，<a href="http://www.runoob.com/mongodb/mongodb-operators-type.html" target="_blank" rel="noopener">完整表格访问这里</a></p>
<p><code>db.col.find({&#39;title&#39; :{$type: 2}})</code> 如果title为String则输出</p>
<h3 id="limit-and-skip"><a href="#limit-and-skip" class="headerlink" title="limit and skip"></a>limit and skip</h3><p><code>db.col.find().limit(2)</code>  只读取两条<br><code>db.col.find().limit(1).skip(1)</code> 跳过第一条，只显示第二条<br>skip默认为0</p>
<h3 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort()方法"></a>sort()方法</h3><p>1升序，-1降序</p>
<p><code>db.col.find().sort({key: 1})</code></p>
<p>例子<br><code>db.col.find({}, {&#39;title&#39;: 1, _id: 0}).sort({&#39;likes&#39;: -1})</code></p>
]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的递归算法</title>
    <url>/2017/04/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种特殊的数据结构，有一个根节点，根节点下面有一左一右两个子节点，每个子节点又有各自的子节点，层层深入成树状。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>关于二叉树的遍历我只学习了递归遍历，非递归遍历比较复杂还是很理解。</p>
<p>递归遍历分为先序，中序和后序。用三个字母表示递归遍历可以很好理解：</p>
<p>D: 访问根节点，L： 遍历根节点的左子树，R：遍历根节点的右子树。</p>
<p>先序遍历：DLR</p>
<p>中序遍历：LDR</p>
<p>后序遍历：LRD</p>
<a id="more"></a>
<h4 id="先序遍历的递归算法"><a href="#先序遍历的递归算法" class="headerlink" title="先序遍历的递归算法"></a>先序遍历的递归算法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(node.value);</span><br><span class="line">		preOrder(node.left);</span><br><span class="line">		preOrder(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历的递归算法"><a href="#中序遍历的递归算法" class="headerlink" title="中序遍历的递归算法"></a>中序遍历的递归算法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">		inOrder(node.left);</span><br><span class="line">		<span class="built_in">console</span>.log(node.value);</span><br><span class="line">		inOrder(node.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历的递归算法"><a href="#后序遍历的递归算法" class="headerlink" title="后序遍历的递归算法"></a>后序遍历的递归算法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">		postOrder(node.left);</span><br><span class="line">		postOrder(node.right);</span><br><span class="line">		<span class="built_in">console</span>.log(node.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更详细的二叉树算法可以查看<a href="https://segmentfault.com/a/1190000004620352" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="定时问题"><a href="#定时问题" class="headerlink" title="定时问题"></a>定时问题</h3><p>遇到的一个难题是如何实现间隔一段时间（500ms）改变节点的颜色，这就需要用到<code>setTimeout()</code>这个方法。刚开始的想法是把定时函数写进递归函数里面，让每次递归都执行<code>setTimeout()</code>，但是这个方法行不通，会改变每个节点出现的顺序，而且函数执行结束的时间小于定时时间，导致想要达到的效果一瞬间全部执行完毕，而不是按规定的时间一个一个出现，这个理解可能有点错误，但是没办法达到想要的效果，所以放弃。</p>
<p>我的方法是把遍历出来的值放进数组里，然后再用数组完成想要做的各种操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">		preOrder(node.left);</span><br><span class="line">		preOrder(node.right);</span><br><span class="line">		preList.push(node.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; preList.length; i++) &#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(preList[i]);  <span class="comment">// 这样就可以按顺序每隔一段时间打印出一个数字</span></span><br><span class="line">	&#125;, <span class="number">500</span> * i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《Algorithms Unlocked》读书笔记3——计数排序</title>
    <url>/2017/04/16/%E3%80%8AAlgorithms-Unlocked%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/subject/20421419/" target="_blank" rel="noopener">《Algorithms Unlocked》</a>是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础，算是啃CLRS前的开胃菜和辅助教材。如果CLRS的厚度让人望而生畏，这本200多页的小读本刚好合适带你入门。</p>
<p>书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。</p>
<h2 id="超越下界"><a href="#超越下界" class="headerlink" title="超越下界"></a>超越下界</h2><p>之前的四个排序算法——选择排序、插入排序、归并排序、快速排序都是依赖于对排序关键字进行的比较。他们的决策依据都是“如果这个元素的排序关键字比另一个元素的排序关键字小，那么就进行相应操作，否则，进行其他操作或者什么也不做。”假如我们还是依赖这一规则，无论是简单或复杂的算法或者还没被发现的算法都无法突破这一下界（最坏情况下所需要的最小时间）。所以我们需要更改游戏规则，不让算法利用比较来进行排序。</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>假设我们有一个数组，该数组内的元素都是 0~m-1 范围内的整数。例如 <code>let array = [4, 1, 5, 0, 1, 6, 5, 1, 5, 3]</code> 。如果我们可以知道排序关键字为 5 的元素有三个，并且刚好有 6 个元素的排序关键字小于 5，那么三个 5 应该位于位置6、7、8上。</p>
<p>首先我们要计算出有多少个元素的排序关键字等于某个值。比如有 3 个元素的排序关键字等于 5。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m:定义了数组array中元素的取值范围 0~m-1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countKeysEqual</span>(<span class="params">array, m</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空数组，长度为m，给每个元素赋值0</span></span><br><span class="line">  <span class="comment">// 为什么要有这一步，万一哪个值array里没有就会变成NaN</span></span><br><span class="line">  <span class="keyword">let</span> equal = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    equal[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">    <span class="comment">// 把array中的元素作为equal数组的索引值</span></span><br><span class="line">    <span class="comment">// 该索引值在equal中对应的值为该元素在array中出现的次数</span></span><br><span class="line">    <span class="keyword">let</span> key = array[j];</span><br><span class="line">    equal[key] += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> equal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>接着我们计算出有多少个元素的排序关键字小于该值。比如有 6 个元素的排序关键字小于 5.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// equal 为上个函数返回的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countKeysLess</span>(<span class="params">equal, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> less = [];</span><br><span class="line">  less[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="comment">// less[i] = equal[0] + equal[1] + ... + equal[i - 1]</span></span><br><span class="line">    less[i] = less[i - <span class="number">1</span>] + equal[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> less;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦得到less数组，我们就可以知道每个元素应该放在哪个位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据less可以得知元素在数组中的位置</span></span><br><span class="line"><span class="comment">// 重排数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rearrange</span>(<span class="params">array, less, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arrB = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = array[i];</span><br><span class="line">    <span class="comment">// 有几个小于key的元素排在key前面，则为key值在arrB中的索引</span></span><br><span class="line">    <span class="comment">// 比如数组[0, 1, 1, 2]，有3个排序关键字小于2，则2的索引为3</span></span><br><span class="line">    <span class="keyword">let</span> index = less[key];</span><br><span class="line">    arrB[index] = array[i];</span><br><span class="line">    <span class="comment">// 自增1，相同值的元素排在该值后一位</span></span><br><span class="line">    less[key] += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arrB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把三个函数组合在一起构成计数排序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m:定义了数组array中元素的取值范围 0~m-1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSort</span>(<span class="params">array, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> equal = countKeysEqual(array, m);</span><br><span class="line">  <span class="keyword">let</span> less = countKeysLess(equal, m);</span><br><span class="line">  <span class="keyword">let</span> arrB = rearrange(array, less, m);</span><br><span class="line">  <span class="keyword">return</span> arrB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计数排序能够超越比较排序的下界，因为它从来不会对排序关键字进行比较。反之，它将排序关键字作为数组的索引，能进行这样的操作是因为排序关键字均是非常小的整数。如果排序关键字是带有分数的实数，或者是字符串，那么我们就不能使用计数排序了。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>《Algorithms Unlocked》读书笔记2——二分查找和排序算法</title>
    <url>/2017/04/16/%E3%80%8AAlgorithms-Unlocked%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/subject/20421419/" target="_blank" rel="noopener">《Algorithms Unlocked》</a>是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础，算是啃CLRS前的开胃菜和辅助教材。如果CLRS的厚度让人望而生畏，这本200多页的小读本刚好合适带你入门。</p>
<p>书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>在排好序的数组中查找目标值x。在p到r区间中，总是取索引为q的中间值与x进行比较，如果array[q]大于x，则比较p到q-1区间，否则比较q+1到r区间，直到array[q]等于x或p&gt;r。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用二分法在已经排好序的数组中查找值x</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">array, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> r = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="built_in">Math</span>.round((p + r) / <span class="number">2</span>);  <span class="comment">//四舍五入取整</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (array[q] === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[q] &gt; x) &#123;</span><br><span class="line">        <span class="comment">// 如果q没有减一，遇到找不到x的情况，</span></span><br><span class="line">        <span class="comment">// 就会陷入while循环中出不来，因为p会一直等于r</span></span><br><span class="line">        r = q - <span class="number">1</span>; </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = q + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'NOT-FOUND'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>也可以把二分查找写成递归风格。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分法递归风格</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveBinarySearch</span>(<span class="params">array, p, r, x</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p &gt; r) &#123;  <span class="comment">// 基础情况</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'NOT-FOUND'</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> q = <span class="built_in">Math</span>.round((p + r) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array[q] === x) &#123;  <span class="comment">// 基础情况</span></span><br><span class="line">    <span class="built_in">console</span>.log(q);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[q] &gt; x) &#123;</span><br><span class="line">      recursiveBinarySearch(array, p, q<span class="number">-1</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      recursiveBinarySearch(array, q+<span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>从第一个元素开始遍历，把该元素跟在它之后的所有元素进行比较，选出最小的元素放入该位置。</p>
<p>以书架上的书本排序为例。我们看一眼书架上的第一本书的书名，接着与第二本进行比较，如果第二本书的书名第一个字母的顺序小于第一本，那我们忘掉第一本书的书名，记下第二本书的书名，此时我们并没有对书籍进行移动，只是比较了书名的顺序，并把顺序最小的书名记在脑子里。直到与最后一本进行比较结束，我们把脑子里顺序最小的书名对应的书与第一本书对调了一下位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> smallest = i;</span><br><span class="line">    <span class="keyword">let</span> key = array[i]; <span class="comment">// 保存当前值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">      <span class="comment">// 比较当前值和最小值，如果当前值小于最小值则把当前值的索引赋给smallest</span></span><br><span class="line">      <span class="keyword">if</span> (array[j] &lt; array[smallest]) &#123;</span><br><span class="line">        smallest = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最小值和当前值交换</span></span><br><span class="line">    array[i] = array[smallest];</span><br><span class="line">    array[smallest] = key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序效率很低，因为选择排序进行了较多的比较操作，但移动元素的操作次数很少。所以当遇到移动元素相当耗时——或者它们所占空间很大或者它们存储在一个存储较慢的设备中——那么选择排序可能是一个合适的算法。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>以书架为例，假设前4个位置已经排好序了，我们拿起第五本书与第四本进行比较，如果第四本大于第五本，把第四本向右移动一个位置，再把第三本与第五本进行比较，如果第三本还大于第五本，把第三本向右移动一个位置，刚好放入第四本空出来的位置。直到遇到一本小于第五本的书或者已经没有书可以比较了，把第五本书插入小于它的那本书的后面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = array[i];  <span class="comment">// 把当前操作值保存到key中</span></span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;       <span class="comment">// j 为当前值的前一位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在j大于等于0且前一位大于当前值时，前一位向右移动一个位置</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">      array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">      j -= <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 直到遇到array[j]小于当前操作值或者j小于0时，把当前值插入所空出来的位置    </span></span><br><span class="line">    array[j+<span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序与选择排序时间差不多，如果移动操作太过耗时最好用选择排序。插入排序适用于数组一开始就已经“基本有序”的状态。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序中使用一个被称为<strong>分治法</strong>的通用模式。在分治法中，我们将原问题分解为类似原问题的子问题，并递归的求解这些子问题，然后再合并这些子问题的解来得出原问题的解。</p>
<ol>
<li><strong>分解：</strong>把一个问题分解为多个子问题，这些子问题是更小实例上的原问题。</li>
<li><strong>解决：</strong>递归地求解子问题。当子问题足够小时，按照基础情况来求解。</li>
<li><strong>合并：</strong>把子问题的解合并成原问题的解。</li>
</ol>
<p>在归并排序中，我们把数组不断用二分法分解成两个小数组，直到每个数组只剩一个元素（基础情况）。再把小数组排好序并进行合并。</p>
<p><img data-src="http://omwf3ob75.bkt.clouddn.com/mergesort1.jpeg" alt="mergesort1"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array: 数组</span></span><br><span class="line"><span class="comment">// p: 开始索引</span></span><br><span class="line"><span class="comment">// r: 末尾索引</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">array, p, r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不可以用四舍五入，找了一夜的bug竟然是因为四舍五入这个小蹄子</span></span><br><span class="line">    <span class="keyword">let</span> q = <span class="built_in">Math</span>.floor((p + r) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 递归调用，把数组拆分成两部分，直到每个数组只剩一个元素</span></span><br><span class="line">    mergeSort(array, p, q);</span><br><span class="line">    mergeSort(array, q + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把两个子数组排序并合并</span></span><br><span class="line">    merge(array, p, q, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的真正工作发生在 <code>merge</code> 函数中。归并排序不是原址的。</p>
<p>假设有两堆已经排好序的书，书堆A和书堆B。把A中的第一本与B中的第一本拿起来比较，小的那本放入书架中，再把A中的“第一本”和B中的“第一本”进行比较，此时的“第一本”不一定是刚才的第一本了，因为已经有一本书放入书架了，不过该书堆的“第一本”任然是该书堆中最小的一本。直到把两堆书全部放入书架。</p>
<p><img data-src="http://omwf3ob75.bkt.clouddn.com/mergersort2.jpeg" alt="mergesort2"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">array, p, q, r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n1 = q - p + <span class="number">1</span>;  <span class="comment">// 子数组的长度</span></span><br><span class="line">  <span class="keyword">let</span> n2 = r - q;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把两个子数组拷贝到B、C数组中</span></span><br><span class="line">  <span class="comment">// slice不包含end参数，所以end参数要加一</span></span><br><span class="line">  <span class="keyword">let</span> arrB = array.slice(p, q + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> arrC = array.slice(q + <span class="number">1</span>, r + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个数组的最后一个元素设为无穷大值，确保了无需再检查数组中是否有剩余元素</span></span><br><span class="line">  arrB[n1] = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  arrC[n2] = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为回填入原数组的个数是固定的，所以无穷大值不会被填入，也无需判断是否有剩余</span></span><br><span class="line">  <span class="comment">// 一旦B、C两个数组中的所有元素拷贝完就自动终止</span></span><br><span class="line">  <span class="comment">// 因为B、C中的元素已经按照非递减顺序排好了，所以最小索引值对应的就是最小值</span></span><br><span class="line">  <span class="comment">// 两个子数组的最小值比较，小的则为当前最小值</span></span><br><span class="line">  <span class="keyword">let</span> i = j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = p; k &lt; r + <span class="number">1</span>; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arrB[i] &lt; arrC[j]) &#123;</span><br><span class="line">      array[k] = arrB[i];</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      array[k] = arrC[j];</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于归并排序不是在原址上工作，需要拷贝出子数组，如果你的储存空间较小或空间非常宝贵，可能不适合使用归并排序。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>与归并排序类似，快速排序也是使用分治模式。与归并排序不同的是，快速排序是在原址上工作的，归并排序是拷贝出两个子数组进行操作并不在原址上工作。</p>
<p>在书架中随机挑选一本书作为<strong>主元</strong>（这里我们总是选择位于书架最末尾的那本书），所有小于主元的书放在主元左侧，所有大于或等于主元的书放在主元右侧，这时就把书分为左右两组（不包括主元），再分别对这两组书进行相同的操作（递归），直到子数组只剩一本书触发基础情况。</p>
<p><img data-src="http://omwf3ob75.bkt.clouddn.com/quicksort1.jpeg" alt="quicksort1"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">array, p, r</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> q = partition(array, p, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归中不再包含array[q]，因为它已经处在正确的位置（左边所有元素都小于它，右边所有元素都大于或等于它）</span></span><br><span class="line">    <span class="comment">// 如果递归调用还包含array[q]，就会陷入死循环</span></span><br><span class="line">    quickSort(array, p, q - <span class="number">1</span>);</span><br><span class="line">    quickSort(array, q + <span class="number">1</span>, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重要的操作都在 <code>partition</code> 函数中。这个函数把数组按照大于或小于主元分为左右两堆，并返回主元所在位置的索引q。注意，左右两堆数组并不是有序的（见上图），只是大于或小于主元。</p>
<p>在书架中随机挑选一本书作为<strong>主元</strong>（这里我们总是选择位于书架最末尾的那本书），此时主元位于最末尾。还未进行比较的为未知组，称为<em>组U</em>，位于主元左侧。小于主元的称为<em>组L</em>，位于书架最左侧。大于或小于主元的称为<em>组R</em>，位于组L左侧组U右侧。如下图。</p>
<p>我们拿起组U中最左侧的那本书，与主元进行比较，如果小于主元则放入组L，大于或等于主元则放入组R。放入组R的操作比较简单，只需要把组R和组U的分割线往右移一位，无需移动书籍。</p>
<p>放入组L的操作则比较复杂。我们将它与组R中最左侧的书籍进行调换，并将组L和组R之间的分割线向右移一位，将组R和组U的分割线向右移一位。如下图</p>
<p><img data-src="http://omwf3ob75.bkt.clouddn.com/quicksort2.jpeg" alt="quicksort2"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主元：数组中随机挑选单独的一个数（这里我们总是选数组中的最后一位）array[r]</span></span><br><span class="line"><span class="comment">// 组L（左侧组）：所有小于主元的数，array[p...q-1]</span></span><br><span class="line"><span class="comment">// 组R（右侧组）：所有大于或等于主元的数，array[q...u-1]</span></span><br><span class="line"><span class="comment">// 组U（未知组）：还未进行比较的数，array[u...r-1]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, p, r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> q = p;</span><br><span class="line">  <span class="comment">// 遍历array[p...r-1]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> u = p; u &lt; r; u++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未知数小于主元，放入组L</span></span><br><span class="line">    <span class="keyword">if</span> (array[u] &lt; array[r]) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把未知数和组R最左侧值(array[q])进行交换，并让q和u往右移一位(加1)</span></span><br><span class="line">      <span class="keyword">let</span> key = array[q];</span><br><span class="line">      array[q] = array[u];</span><br><span class="line">      array[u] = key;</span><br><span class="line">      q += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未知数大于或等于主元，放入组R</span></span><br><span class="line">    <span class="comment">// 无需其他操作，只需要把u往右移一位</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把主元和组R最左侧值(array[q])进行交换，让主元位于组L合组R中间</span></span><br><span class="line">  <span class="keyword">let</span> key = array[q];</span><br><span class="line">  array[q] = array[r];</span><br><span class="line">  array[r] = key;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例的快速排序总是选择最末尾的元素作为主元，称为<em>确定的快速排序</em>。如果每次选择主元时都从数组中随机选择，则称为<em>随机快速排序</em>，随机快速排序在测试中会快于确定的快速排序。</p>
<p>根据数据量的不同，储存空间的大小，存储速度的快慢，每个排序方法都有不同的表现，并不是说哪个方法一定是最快的，也不一定最快就是最好的，合适才是最好的。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>《Algorithms Unlocked》读书笔记1——循环和递归</title>
    <url>/2017/04/10/%E3%80%8AAlgorithms-Unlocked%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E5%92%8C%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>《Algorithms Unlocked》是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础。</p>
<p>书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。</p>
<h2 id="循环和查找"><a href="#循环和查找" class="headerlink" title="循环和查找"></a>循环和查找</h2><p>首先是三个简单的查找。目的是从数组中查找一个特定的值。</p>
<p>array: 一个数组</p>
<p>x: 要查找的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的线性查找</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linearSearch</span>(<span class="params">array, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="string">'NOT-FOUND'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === x) &#123;</span><br><span class="line">      <span class="comment">// 虽然找到了i, 但没有返回继续查找，直到 for 结束</span></span><br><span class="line">      answer = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(answer);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然找到了目标值，但for循环依然继续遍历直到结束，下面是优化</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化的查找，找到目标后立刻返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">betterLinearSearch</span>(<span class="params">array, x</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === x) &#123;</span><br><span class="line">      <span class="comment">// 直接返回</span></span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'NOT-FOUND'</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个问题是：假如直到最后都没有找到目标值，将试图访问越过数组末尾的元素。书上说：“在计算机程序中，当你试图访问越过数组末尾的元素时，结果通常是糟糕的。你的程序可能会崩溃，也可能会损坏数据。” </p>
<p>宁可信其有，不可信其无啊。继续优化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更优的写法</span></span><br><span class="line"><span class="comment">// 总是让 for 循环可以结束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sentinelLinearSearch</span>(<span class="params">array, x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = array.length - <span class="number">1</span>; <span class="comment">// 最后一个元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数组最后一个值保存到last变量中</span></span><br><span class="line">  <span class="keyword">let</span> last = array[n]</span><br><span class="line">  <span class="comment">// 把数组最后一个值替换成目标值</span></span><br><span class="line">  array[n] = x;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断数组中是否有目标值x，即使没有，数组的最后一个值也一定是目标值，避免越过数组末尾的访问</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (array[i] !== x) &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果i小于数组长度，或者最后一个值为目标值x，则返回i</span></span><br><span class="line">  array[n] = last;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; n || last === x) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'NOT-FOUND'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个方案在进行循环遍历的时候只进行了一个判断——array[i]是否等于x，而上面的两种方案在进行for循环时都要进行i是否大于length的判断和array[i]是否等于x两个判断。所以当数组大到一定程度的时候，第三个方案效率大于上面两个方案。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归是指在函数中对函数自身进行调用。</p>
<p>递归有两个特性：</p>
<ol>
<li>必须有一个或对个基础情况，它是指不用递归而直接计算出结果。比如下面例子中：当 n=0 时，基础情况发生，f(0) = 1;</li>
<li>程序中的每个递归调用一定是通过一系列关于同一个问题的子问题的求解而最终迭代到基础情况。</li>
</ol>
<p>下面是一个经典的递归例子，计算阶乘。</p>
<p>当n=0时，n! = 1 且 n! = n(n-1)(n-2)…3•2•1 (n≥0)</p>
<p>比如：5! = 5•4•3•2•1 = 120</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的查找算法也可以写成递归风格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性查找的递归风格</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveLinearSearch</span>(<span class="params">array, i, x</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i &lt; array.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === x) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> recursiveLinearSearch(array, i+<span class="number">1</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'NOT-FOUND'</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 的简单使用</title>
    <url>/2016/11/20/Git-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>一直在使用Git，仅限于简单的使用，但还是记不住几个简单。在这边总结一下，加深印象，也方便查找。</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>平常主要在windows和ubuntu上工作，就以windows为例，Linux和Mac平台应该也差不多，反而是windows上坑比较多。</p>
<p>在windows上首先要下载Git，谷歌上搜一下，傻瓜式下载安装。Linux上不同发行版会有点小差异，不过你可以输入git，系统会提示你如何进行安装。</p>
<p>我们可以简单的把Git看成三个部分：本地、暂存区、远程仓库。下面我们来简单介绍各部分的作用。</p>
<h3 id="存入暂存区"><a href="#存入暂存区" class="headerlink" title="存入暂存区"></a>存入暂存区</h3><a id="more"></a>
<ol>
<li><p>在命令行中进入该目录，输入 <code>git init</code> 命令，该命令会把本地文件夹变成Git可以管理的仓库，主要是生成 <em>.git</em> 文件。</p>
</li>
<li><p><code>git add fileName</code> 命令可以添加想要上传的文件，比如添加 <em>readme.md</em> 就输入 <code>git add readme.md</code>，这个命令可以多次重复使用，添加多个文件。如果要添加一整个文件夹也是同理， <code>git add 文件夹名</code>。比如 <code>git add images</code>。</p>
</li>
<li><p>把添加的文件上传至暂存区，并附上说明：<code>git commit -m &quot;add readme&quot;</code>。</p>
</li>
</ol>
<p>经过这三步就可以把本地文件上传至暂存区。这个时候如果我们在修改本地文件时不小心改乱了，还可以执行版本退回，也可以执行撤销修改，删除文件等操作。由于是简单的入门教程，本文不展开讨论。</p>
<h3 id="添加SSH-key"><a href="#添加SSH-key" class="headerlink" title="添加SSH key"></a>添加SSH key</h3><p>之前的操作都是在本地上进行的，现在我们需要把暂存区的文件提交到GitHub仓库中。</p>
<p>首先我们需要有一个GitHub账号，然后利用ssh秘钥，让GitHub可以识别你的电脑。</p>
<ol>
<li><p>在本地创建SSH Key:</p>
<p> <code>$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p>
<p> 把邮箱地址换成你自己的地址，然后一路回车，之后你就可以再用户主目录中找到 <em>.ssh</em> 目录，里面有 <em>id_rsa</em> 和 <em>id_rsa.pub</em> 两个文件，<em>id_rsa</em> 是私钥，不可以泄露，<em>id_rsa.pub</em> 是公钥，我们需要把它复制到GitHub中。</p>
</li>
<li><p>登录你的GitHub账号，在settings中找到SSH and GPG keys选项，点击New SSH key，把 <em>id_rsa.pub</em> 中的内容复制到Key中，并取一个title。点击Add SSH key就完成了。</p>
</li>
</ol>
<p>如果你有多个电脑，可以添加多个key，一个电脑对应一个KEY。光是让GitHub认得这是你的电脑还不够，我们还要把本地仓库与远程仓库进行绑定。</p>
<p>本地仓库其实就是本地文件夹，但我们还没有建立远程仓库，接下来教大家如何建立远程仓库。</p>
<h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><p>在你的GitHub的头像旁边有一个加号，点击加号在选择New repository,填好Repository name和Description，点击Create repository，一个远程仓库就建立好了。</p>
<p>接下来我们要把本地仓库与远程仓库进行绑定，在本地仓库文件夹中执行：</p>
<p><code>$ git remote add origin git@github.com:yourName/repositoryName.git</code></p>
<p>把 <em>yourName</em> 换成你的GitHub的账户名，把repositoryName换成刚刚建好的远程仓库名，就可以把本地仓库与远程仓库进行绑定。</p>
<p>本地仓库和远程仓库的名称并不一定要相同，不过相同的名称方便我们管理。</p>
<p>这时我们就可以把本地仓库的内容推送至远程仓库了：</p>
<p><code>$ git push -u origin master</code></p>
<p>第一次推送时我们加上 <em>-u</em> 参数，可以把本地的 <em>master</em> 分支和远程的 <em>master</em> 分支关联起来，以后就可以简化我们的推送命令。</p>
<p><code>$ git push origin master</code></p>
<p>至此，我们已经完成了从本地到远程的所有操作，基本可以满足平时的使用。</p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>如果你在windows上进行工作，我建议使用GitHub的桌面端，因为windows上总是会有一些奇奇怪怪的错误。比如你的用户文件夹是中文名，就会产生问题，而解决这些莫名其妙的问题其实是在浪费时间，最好的解决办法就是换个用户名或者换台电脑。GitHub的桌面端简单易用，不需要我们手动绑定SSH key，只需登录账户就可以使用了。</p>
<p>如果你是新手，遇到难以解决的问题，在试图解决问题但没有成功也没有人能够帮助你的时候，可以先把本地仓库先备份到其他地方，然后删除掉你的本地仓库，重新从远程仓库克隆一份，再进行操作。克隆的命令如下：</p>
<p><code>$ git clone git@github.com:yourName/repositoryName.git</code></p>
<p>这个方法可以帮助你解决一部分问题，但不保证你遇到的所有问题都能解决。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈JavaScript中的apply、call、bind</title>
    <url>/2016/11/17/%E6%B5%85%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84apply%E3%80%81call%E3%80%81bind/</url>
    <content><![CDATA[<p>apply,call,bine 这三兄弟经常让初学者感到疑惑。前两天准备面试时特地做了个比较，其实理解起来也不会太难。</p>
<a id="more"></a>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN</a>上的定义：<br>The apply() method calls a function with a given this value and arguments provided as an array (or an array-like object).</p>
<p><strong>apply()</strong> 方法调用一个函数，指定该函数的 <strong>this</strong> 值并将一个数组（或类数组对象）作为该函数的参数。</p>
<h3 id="语法-Syntax"><a href="#语法-Syntax" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h3><p><code>fun.apply(thisArg,[argsArray])</code></p>
<p>直接上代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arg + <span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line">sayColor.apply(obj, [<span class="string">"The color is"</span>]); <span class="comment">//输出"The color is blue"</span></span><br></pre></td></tr></table></figure><br>此时 <em>this</em> 指向 <em>obj</em> ，则 <em>this.color</em> 为 <em>obj</em> 的 <em>color</em> 属性，则输出 <em>The color is blue</em>。</p>
<!-- more -->
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p><code>call()</code> 与 <code>apply()</code> 类似，区别在于 <code>apply()</code> 的第二个参数为数组，而 <code>call()</code> 把参数跟在第一个参数后面，并且可以跟多个参数。</p>
<h3 id="语法-Syntax-1"><a href="#语法-Syntax-1" class="headerlink" title="语法 (Syntax)"></a>语法 (Syntax)</h3><p><code>fun.call(thisArg, arg1, arg2, arg3 ...)</code></p>
<p>看代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayClothe</span>(<span class="params">arg1,arg2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg1 + <span class="keyword">this</span>.color + arg2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line">sayClothe.call(obj, <span class="string">"This is a "</span>, <span class="string">" clothe"</span> ); <span class="comment">//输出"This is a blue clothe"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind()</code> 与 <code>call()</code> 类似，有一点不同在于 <code>bind()</code> 返回一个新函数(new function)，我们可以随时调用该函数。</p>
<h2 id="语法-Syntax-2"><a href="#语法-Syntax-2" class="headerlink" title="语法(Syntax)"></a>语法(Syntax)</h2><p><code>fun.bind(thisArg, arg1, arg2, arg3 ...)</code></p>
<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><p>返回一个具有指定 <code>this</code> 和初始参数的函数副本。</p>
<p>看代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayClothe</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg1 + <span class="keyword">this</span>.color + arg2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sayClothe2 = sayClothe.bind(obj, <span class="string">"This is a "</span>, <span class="string">" clothe"</span>);</span><br><span class="line">sayClothe2(); <span class="comment">//输出 "This is a blue clothe"</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>有时候我们会碰到 <code>Array.prototype.slice.call(arguments)</code> 这种用法。许多人会疑惑，直接使用 <code>arguments.slice()</code> 不就行了吗，为什么要多此一举。</p>
<p>原因在于，arguments 并不是真正的数组对象，只是 <em>array-like object</em> ，所以它并没有 slice 这个方法。而 <code>Array.prototype.slice.call(arguments)</code> 可以理解为把 slice 的对象指向 arguments ,从而让 arguments 可以使用 slice 方法。如果直接使用 <code>arguments.slice()</code> 则会报错。</p>
<p><code>bind()</code> 的另一个用法则是让函数拥有预设参数，而又跟预设参数有所不同。</p>
<p>以下例子结合上面两条规则 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">本例出自MDN</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Create a function with a preset leading arguments</span></span><br><span class="line"><span class="keyword">var</span> leadingThirtysevenList = list.bind(<span class="literal">null</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = leadingThirtysevenList();</span><br><span class="line"><span class="comment">//[37]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list3 = leadingThirtysevenList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//[37, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>我们想到预设参数就会理所当然的想到 “如果该函数没有参数就使用预设参数，有参数就使用提供的参数”。不过 <code>bind()</code> 所提供的预设参数功能与此不同。</p>
<p>在我们的印象中， <code>list3</code> 应该输出 <code>[1, 2, 3]</code> 但实际输出的却是 <code>[37, 1, 2, 3]</code>。因为 <code>bind()</code> 的特点，<code>leadingThirtysevenList(1, 2, 3)</code> 可以写为 <code>list.bind(null, 37, 1, 2, 3)</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>apply() call() bind()</code> 三者区别不大，都是用来改变函数的 <em>this</em> 指向。</p>
<p><code>apply()</code> 把 <em>this</em> 所需参数放入一个数组，作为 <code>apply()</code> 的第二个参数传入。当参数不定时，我们可以传入 <em>arguments</em>。 <code>call()</code> 和 <code>bind()</code> 则把参数按顺序依次传入。</p>
<p><code>bind()</code> 返回对应函数，便于稍后调用，而 <code>apply()</code>、<code>call()</code>则立即调用</p>
<p>由于其特性，使用起来千奇百怪，有各种各样有趣的用法，还等待我们去挖掘。</p>
]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
</search>
